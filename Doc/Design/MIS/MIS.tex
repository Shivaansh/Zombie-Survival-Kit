\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{SE 3XA3: Module Interface Specification\\Zombie Survival Kit}

\author{Team \#6, Group 6ix
		\\ Mohammad Hussain hussam17
		\\ Brian Jonatan jonatans
		\\ Shivaansh Prasann prasanns
}

\date{\today}

\begin {document}

\newpage

\section* {Component Items Module}

\subsection*{Template Module}

Item

\subsection* {Uses}

ScriptableObject, Inventory, UnityEngine

\subsection* {Syntax}

\subsubsection* {Exported Types}

Sprite

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Use & ~ & ~ & ~\\
\hline
RemoveFromInventory & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

name: $String$\\
icon: $Sprite$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

This module is used to create a new asset in Unity by creating a new asset menu called "Inventory/Item". Once an item has been created through Unity's asset menu, the state variables are updated directly in Unity by manually typing in the name of the item, and placing the appropriate Sprite for the icon. User will not be tasked to do this; all items available to the user will be created before hand by the developers of Zombie Survival Kit.

\subsubsection* {Access Routine Semantics}

\noindent Use():
\begin{itemize}
\item translation: None
\item output: Prints out to Debug.Log()
\item exception: None
\end{itemize}

\noindent RemoveFromInventory():
\begin{itemize}
\item translation: Calls the "Remove" method from the Inventory class.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {Component Items Consumable Module}

\subsection*{Template Module}

Consumable

\subsection* {Uses}

Item, PlayerStats, System.Collections, System.Collections.Generic, UnityEngine

\subsection* {Syntax}

\subsubsection* {Exported Types}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Use & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

healthModifier: $\mathbb{N}$\\
name: $String$\\
icon: $Sprite$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

This module is used to create a new asset in Unity by creating a new asset menu called "Inventory/Consumable"; item of type Consumable. Once a Consumable has been created through Unity's asset menu, the state variables are updated directly in Unity by manually typing the value of the healthModifier, the name of the item, and placing the appropriate Sprite for the icon. User will not be tasked to do this; all Consumable items available to the user will be created before hand by the developers of Zombie Survival Kit.

\subsubsection* {Access Routine Semantics}

\noindent Use():
\begin{itemize}
\item translation: Calls the base "Use" method from the Item class, the "Eat" method in the PlayerStats class, and "RemoveFromInventory" method from the Item class.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {Component Item Equipment Module}

\subsection*{Template Module}

EquipmentItem

\subsection* {Uses}

Item, EquipmentManager, System.Collections, System.Collections.Generic, UnityEngine

\subsection* {Syntax}

\subsubsection* {Exported Types}

equipmentSlot: \{Head, Chest, Legs, Primaryhand, Offhand, Feet\}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Use & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

equipSlot: $equipmentSlot$\\
attackModifier: $\mathbb{N}$\\
defenceModifier: $\mathbb{N}$\\
name: $String$\\
icon: $Sprite$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

This module is used to create a new asset in Unity by creating a new asset menu called "Inventory/Equipment"; item of type EquipmentItem. Once an EquipmentItem has been created through Unity's asset menu, the state variables are updated directly in Unity by manually choosing which equipmentSlot belongs to the EquipmentItem's equipSlot, typing in the value of the attackModifier, defenceModifer and the name of the EquipmentItem, and placing the appropriate Sprite for the icon. User will not be tasked to do this; all EquipmentItem available to the user will be created before hand by the developers of Zombie Survival Kit.

\subsubsection* {Access Routine Semantics}

\noindent Use():
\begin{itemize}
\item transition: Calls the base "Use" method from the Item class, the "Equip" method in the EquipmentManager class, and "RemoveFromInventory" method from the Item class.
\item output: None
\item exception: None
\end{itemize}

%\subsection*{Local Functions}
%
%pointsInLine: $\mbox{LineT} \rightarrow \mbox{(set of PointT)}$\\
%
%\noindent pointsInLine ($l$) 
%\begin{multline*}
%\equiv \{ i: \mathbb{N} | i \in [0
%  .. (l.\mbox{len} - 1)] : l.\mbox{strt}.\mbox{translate}.(
%\end{multline*} (\wss{\begin{tabular}{|l|l|}
%\hline
%$l.orient = \mbox{N}$ & $(0,1)$\\
%\hline
%$l.orient = \mbox{S}$ & $(0,-1)$\\
%\hline
%$l.orient = \mbox{W}$ & $(-1,0)$\\
%\hline
%$l.orient = \mbox{E}$ & $(1,0)$\\
%\hline
%\end{tabular}}
%
%\noindent adjPt: $\mbox{CompassT} \rightarrow \mbox{PointT}$\\
%adjPt$(ornt) \equiv$
%
%\medskip
%
%\begin{tabular}{|l|l|}
%\hline
%$ornt = \mbox{N}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(0,1)}$\\
%\hline
%$ornt = \mbox{S}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(0,-1)}$\\
%\hline
%$ornt = \mbox{W}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(-1,0)}$\\
%\hline
%$ornt = \mbox{E}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(1,0)}$\\
%\hline
%\end{tabular}

\newpage

\section* {Generic Seq2D Module}

\subsection* {Generic Template Module}

Seq2D(T)

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

Seq2D(T) = ?

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Seq2D & seq of (seq of T), $\mathbb{R}$ & Seq2D & invalid\_argument\\
\hline
set & PointT, T & ~ & outside\_bounds\\
\hline
get & PointT & T & outside\_bounds\\
\hline
getNumRow & ~ & $\mathbb{N}$ & \\
\hline
getNumCol & ~ & $\mathbb{N}$ & \\
\hline
getScale & ~ & $\mathbb{R}$ & \\
\hline
count & T & $\mathbb{N}$ & \\
\hline
count & LineT, T & $\mathbb{N}$ & invalid\_argument\\
\hline
count & PathT, T & $\mathbb{N}$ & invalid\_argument\\
\hline
length & PathT & $\mathbb{R}$ & invalid\_argument\\
\hline
connected & PointT, PointT & $\mathbb{B}$ & invalid\_argument\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$s$: seq of (seq of T)\\
scale: $\mathbb{R}$\\
nRow: $\mathbb{N}$\\
nCol: $\mathbb{N}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

\begin{itemize}
\item The Seq2D(T) constructor is called for each object instance before any
other access routine is called for that object.  The constructor can only be
called once.
\item Assume that the input to the constructor is a sequence of rows, where each
  row is a sequence of elements of type T.  The number of columns (number of
  elements) in each row is assumed to be equal. That is each row
  of the grid has the same number of entries.  $s[i][j]$ means the ith row and
  the jth column.  The 0th row is at the bottom of the map and the 0th column
  is at the leftmost side of the map.
\end{itemize}

\subsubsection* {Access Routine Semantics}

Seq2D($S$, scl):
\begin{itemize}
\item transition: \wss{s, scale, nRow, nCol := S, scl, S.len, S[0].len}
\item output: $\mathit{out} := \mathit{self}$
\item exception: \wss{$scl < 0 \| \lnot(validRow) \| \lnot(validCol) \| S.len \neq S[0].len \implies invalid\_argument$}
\end{itemize}

\noindent set($p, v$):
\begin{itemize}
\item transition: \wss{s[p.y][p.x] := v}
\item exception: \wss{$p.y < 0 \| p.x < 0 \| p.y \geq nRow \| p.x \geq nCol \implies outside\_bounds$}
\end{itemize}

\noindent get($p$):
\begin{itemize}
\item output: \wss{out:= s[p.y][p.x]}
\item exception: \wss{$p.y < 0 \| p.x < 0 \| p.y \geq nRow \| p.x \geq nCol \implies outside\_bounds$}
\end{itemize}

\noindent getNumRow():
\begin{itemize}
\item output: $out := \mbox{nRow}$
\item exception: None
\end{itemize}

\noindent getNumCol():
\begin{itemize}
\item output: $out := \mbox{nCol}$
\item exception: None
\end{itemize}

\noindent getScale():
\begin{itemize}
\item output: $out := \mbox{scale}$
\item exception: None
\end{itemize}

\noindent count($t$: T):
\begin{itemize}
\item output: \wss{$out:= +(\forall i : \mathbb{N} | i \in [0...nRow] \bullet \forall j : \mathbb{N} | j \in [0...nCol] \bullet s[i][j] = t : 1)$}
\item exception: None
\end{itemize}

\noindent count($l$: LineT, $t$: T):
\begin{itemize}
\item output: \wss{$out:= +(\forall i : \mathbb{N} | i \in [l.strt.y...l.end.y] \bullet \forall j : \mathbb{N} | j \in [l.strt.x...l.end.x] \bullet s[i][j] = t : 1$}
\item exception: \wss{$\lnot(validLine(l)) \implies invalid\_argument$}
\end{itemize}

\noindent count($\mathit{pth}$: PathT, $t$: T):
\begin{itemize}
\item output: \wss{$out:= +(\forall k :\mathbb{N} | k \in [0...pth.size-1] \bullet \forall i : \mathbb{N} | i \in [pth[k].strt.y...pth[k].end.y] \bullet \forall j : \mathbb{N} | j \in [pth[k].strt.x...pth[k].end.x] \bullet s[i][j] = t : 1$}
\item exception: \wss{$\lnot(validPath(pth)) \implies invalid\_argument$}
\end{itemize}

\noindent length($\mathit{pth}$: PathT):
\begin{itemize}
\item output: \wss{$out := scl \times pth.len$}
\item exception: \wss{$\lnot(validPath(pth)) \implies invalid\_argument$}
\end{itemize}

\noindent connected($p_1$: PointT, $p_2$: PointT):
\begin{itemize}
\item output: \wss{$out := ((\forall k : \mathbb{N} | k \in [0...pth.size - 1] | \bullet \exists p_1 : PointT | \bullet pointsInPath(pth)[k] = p_1) \land (\forall k : \mathbb{N} | k \in [0...pth.size - 1] | \bullet \exists p_2 : PointT | \bullet pointsInPath(pth)[k] = p_2)) \implies true$}
\item exception: \wss{$\lnot(validPoints(p_1) \land validPoints(p_2)) \implies invalid\_argument)$}

\end{itemize}

\subsection*{Local Functions}

\noindent validRow: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{validRow(i) $\equiv$ $0 < i < nRow = true$, where i $\rightarrow \mathbb{N}$}\\

\noindent validCol: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{validCol(i) $\equiv$ $0 < i < nCol = true$, where i $\rightarrow \mathbb{N}$}\\

\noindent validPoint: $\mbox{PointT} \rightarrow \mathbb{B}$\\
\noindent \wss{validPoint(point) $\equiv$ $(point.x \land point.y) \geq 0\, \land (point.x \land point.y) < (nRow \land nCol) \implies true$,\, where\, point $\rightarrow$ PointT}\\

\noindent validLine: $\mbox{LineT} \rightarrow \mathbb{B}$\\
\noindent \wss{validLine(i) $\equiv$ $(validPoint(l.strt) \land validPoint(l.end))  \implies true$,\, where\, $l \rightarrow$ LineT}\\

\noindent validPath: $\mbox{PathT} \rightarrow \mathbb{B}$\\
\noindent \wss{validPath(i) $\equiv$ $\forall : \mathbb{N} | k \in [0...pth.size - 1] \bullet (validLine(pth[k])) \implies true$,\, where\, pth $\rightarrow$ PathT}\\

\noindent pointsInLine: $\mbox{LineT} \rightarrow \mbox{(set of PointT)}$\\
\noindent pointsInLine ($l$) 
\wss{pointsInLine($l$) $\equiv$  $i: \mathbb{N} | i \in [0 .. (l.len - 1)] : l.strt.translate($ \begin{tabular}{|l|l|}
\hline
$l.orient = \mbox{N}$ & $(0,1)$\\
\hline
$l.orient = \mbox{S}$ & $(0,-1)$\\
\hline
$l.orient = \mbox{W}$ & $(-1,0)$\\
\hline
$l.orient = \mbox{E}$ & $(1,0)$\\
\hline
\end{tabular})}

\noindent pointsInPath: $\mbox{PathT} \rightarrow \mbox{(set of PointT)}$\\
\wss{pointsInPath(p) $\equiv$ $\cup$$(k: \mathbb{N} | k \in [0 .. (p.size - 1)] : (pointsInLine(p[k])))$,\, where\, p $\rightarrow$ PathT}
\noindent pointsInPath($p$) 

\newpage

\section* {LanduseMap Module}

\subsection* {Template Module}

LanduseMapT is Seq2D(LanduseT)

\section* {DEM Module}

\subsection* {Template Module}

DEMT is Seq2D($\mathbb{Z}$)

\newpage

\section*{Critique of Design}

In general, the specifications were easy to follow. However, one thing that could be added are hints to use the local functions for certain exceptions earlier on in each module because some time was wasted to create exceptions beforehand, only to realize that one could use the local functions as exceptions.

\end {document}