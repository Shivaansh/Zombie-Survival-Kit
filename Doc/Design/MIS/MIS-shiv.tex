\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{float}
\usepackage{hyperref}
\usepackage{tabularx}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{SE 3XA3: Module Interface Specification\\Zombie Survival Kit}

\author{Team \#6, Group 6ix
		\\ Mohammad Hussain hussam17
		\\ Brian Jonatan jonatans
		\\ Shivaansh Prasann prasanns
}

\date{\today}

\begin {document}

\maketitle

\pagenumbering{arabic}

\newpage
\section* {Modules}
\begin{description}
\item [\refstepcounter{mnum} \mthemnum \label{mHH}:] Hardware-Hiding Module
\item [\refstepcounter{mnum} \mthemnum \label{mSDI}:] Item (Component)
\item [\refstepcounter{mnum} \mthemnum \label{mSDCI}:] ConsumableItem (Component)
\item [\refstepcounter{mnum} \mthemnum \label{mSDEI}:] EquipmentItem (Component)
\item [\refstepcounter{mnum} \mthemnum \label{mSDEM}:] EquipmentManager (Manager)
\item [\refstepcounter{mnum} \mthemnum \label{mSDIM}:] InventoryManager (Manager)
\item [\refstepcounter{mnum} \mthemnum \label{mBHI}:] Interactable (Object)
\item [\refstepcounter{mnum} \mthemnum \label{mBHE}:] Enemy (Object)
\item [\refstepcounter{mnum} \mthemnum \label{mBHIS}:] ItemStore (Object)
\item [\refstepcounter{mnum} \mthemnum \label{mBHIC}:] InteractableController (Character)
\item [\refstepcounter{mnum} \mthemnum \label{mBHEU}:] EquipmentUI
\item [\refstepcounter{mnum} \mthemnum \label{mBHESU}:] EquipmentSlotUI
\item [\refstepcounter{mnum} \mthemnum \label{mBHIU}:] InventoryUI
\item [\refstepcounter{mnum} \mthemnum \label{mBHISU}:] InventorySlotUI
\item [\refstepcounter{mnum} \mthemnum \label{mBHCC}:] CharacterCombat (Character)
\item [\refstepcounter{mnum} \mthemnum \label{mSDCS}:] CharacterStats (Manager)
\item [\refstepcounter{mnum} \mthemnum \label{mSDPS}:] PlayerStats (Manager)
\item [\refstepcounter{mnum} \mthemnum \label{mSDZS}:] ZombieStats (Manager)
\item [\refstepcounter{mnum} \mthemnum \label{mSDS}:] Stat (Component)
\item [\refstepcounter{mnum} \mthemnum \label{mBHZ}:] Zombie (Object)
\item [\refstepcounter{mnum} \mthemnum \label{mBHFPS}:] FirstPersonController (Character)
\item [\refstepcounter{mnum} \mthemnum \label{mBHG}:] Gun (Object)
\item [\refstepcounter{mnum} \mthemnum \label{mBHBD}:] BulletDamage (Objects)
\end{description}

\section* {\mref{mSDI} Item}

\subsection*{Template Module}

Item

\subsection* {Uses}

\mref{mSDIM}

\subsection* {Syntax}

\subsubsection* {Exported Types}

Sprite

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Use & ~ & ~ & ~\\
\hline
RemoveFromInventory & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

name: $String$\\
icon: $Sprite$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

This module is used to create a new asset in Unity by creating a new asset menu called "Inventory/Item". Once an item has been created through Unity's asset menu, the state variables are updated directly in Unity by manually typing in the name of the item, and placing the appropriate Sprite for the icon. User will not be tasked to do this; all items available to the user will be created before hand by the developers of Zombie Survival Kit.

\subsubsection* {Access Routine Semantics}

\noindent Use():
\begin{itemize}
\item translation: None
\item output: Prints out to Debug.Log()
\item exception: None
\end{itemize}

\noindent RemoveFromInventory():
\begin{itemize}
\item translation: Calls the "Remove" method from the Inventory class.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mSDCI} ConsumableItem}

\subsection*{Template Module}

ConsumableItem

\subsection* {Uses}

\mref{mSDI}, \mref{mSDIM}

\subsection* {Syntax}

\subsubsection* {Exported Types}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Use & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

healthModifier: $\mathbb{N}$\\
name: $String$\\
icon: $Sprite$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

This module is used to create a new asset in Unity by creating a new asset menu called "Inventory/Consumable"; item of type Consumable. Once a Consumable has been created through Unity's asset menu, the state variables are updated directly in Unity by manually typing the value of the healthModifier, the name of the item, and placing the appropriate Sprite for the icon. User will not be tasked to do this; all Consumable items available to the user will be created before hand by the developers of Zombie Survival Kit.

\subsubsection* {Access Routine Semantics}

\noindent Use():
\begin{itemize}
\item translation: Calls the base "Use" method from the Item class, the "Eat" method in the PlayerStats class, and "RemoveFromInventory" method from the Item class.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mSDEI} EquipmentItem}

\subsection*{Template Module}

EquipmentItem

\subsection* {Uses}

Item, EquipmentManager, System.Collections, System.Collections.Generic, UnityEngine

\subsection* {Syntax}

\subsubsection* {Exported Types}

equipmentSlot: \{Head, Chest, Legs, Primaryhand, Offhand, Feet\}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Use & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

equipSlot: $equipmentSlot$\\
attackModifier: $\mathbb{N}$\\
defenceModifier: $\mathbb{N}$\\
name: $String$\\
icon: $Sprite$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

This module is used to create a new asset in Unity by creating a new asset menu called "Inventory/Equipment"; item of type EquipmentItem. Once an EquipmentItem has been created through Unity's asset menu, the state variables are updated directly in Unity by manually choosing which equipmentSlot belongs to the EquipmentItem's equipSlot, typing in the value of the attackModifier, defenceModifer and the name of the EquipmentItem, and placing the appropriate Sprite for the icon. User will not be tasked to do this; all EquipmentItem available to the user will be created before hand by the developers of Zombie Survival Kit.

\subsubsection* {Access Routine Semantics}

\noindent Use():
\begin{itemize}
\item transition: Calls the base "Use" method from the Item class, the "Equip" method in the EquipmentManager class, and "RemoveFromInventory" method from the Item class.
\item output: None
\item exception: None
\end{itemize}

%\subsection*{Local Functions}
%
%pointsInLine: $\mbox{LineT} \rightarrow \mbox{(set of PointT)}$\\
%
%\noindent pointsInLine ($l$) 
%\begin{multline*}
%\equiv \{ i: \mathbb{N} | i \in [0
%  .. (l.\mbox{len} - 1)] : l.\mbox{strt}.\mbox{translate}.(
%\end{multline*} (\wss{\begin{tabular}{|l|l|}
%\hline
%$l.orient = \mbox{N}$ & $(0,1)$\\
%\hline
%$l.orient = \mbox{S}$ & $(0,-1)$\\
%\hline
%$l.orient = \mbox{W}$ & $(-1,0)$\\
%\hline
%$l.orient = \mbox{E}$ & $(1,0)$\\
%\hline
%\end{tabular}}
%
%\noindent adjPt: $\mbox{CompassT} \rightarrow \mbox{PointT}$\\
%adjPt$(ornt) \equiv$
%
%\medskip
%
%\begin{tabular}{|l|l|}
%\hline
%$ornt = \mbox{N}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(0,1)}$\\
%\hline
%$ornt = \mbox{S}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(0,-1)}$\\
%\hline
%$ornt = \mbox{W}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(-1,0)}$\\
%\hline
%$ornt = \mbox{E}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{(1,0)}$\\
%\hline
%\end{tabular}

\newpage

\section* {\mref{mSDEM} EquipmentManager}

\subsection*{Template Module}

EquipmentManager

\subsection* {Uses}

\mref{mSDI}, \mref{mSDEM}, \mref{mBHESU}

\subsection* {Syntax}

\subsubsection* {Exported Types}

EquipmentItem, Inventory, equipmentSlot

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
OnEquipmentChanged & EquipmentItem, EquipmentItem & ~  & ~\\
Start &~ & ~  & ~\\
Update &~ & ~  & ~\\
Equip & EquipmentItem & ~  & ~\\
Unequip & $\mathbb{N}$ & ~  & ~\\
UnequipAll &~ & ~  & ~ \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

equippedItems: array of $EquipmentItem$\\
inventory: $Inventory$

\subsubsection* {State Invariant}

instance: $EquipmentManager$

\subsubsection* {Assumptions}

This module updates automatically as the user changes the player's equipment by equipping or unequipping EquipmentItems

\subsubsection* {Access Routine Semantics}

\noindent OnEquipmentChanged(EquipmentItem newEquipment, EquipmentItem oldEquipment):
\begin{itemize}
\item description: Is called whenever a change occurs in the the state variable equippedItems. It is a delegate function that allows itself to perform different functionalities in different modules.*
\item translation: *Updated in different modules; does nothing in this module*
\item output: None
\item exception: None
\end{itemize}

\noindent Start():
\begin{itemize}
\item translation: Initializes state variable equippedItems with the length of equipmentSlot (an enum type) and state variable inventory as an instance of the Inventory module.
\item output: None
\item exception: None
\end{itemize}

\noindent Update():
\begin{itemize}
\item translation: Upon keyboard input of "U", perform UnequipAll().
\item output: None
\item exception: None
\end{itemize}

\noindent Equip(EquipmentItem newEquipment):
\begin{itemize}
\item translation: Stores the newEquipment item into equippedItems[newEquipment.equipSlot].
\item output: None
\item exception: None
\end{itemize}

\noindent Unequip(int SlotIndex):
\begin{itemize}
\item translation: Removes the EquipmentItem in equippedItems[SlotIndex].
\item output: None
\item exception: None
\end{itemize}

\noindent UnequipAll():
\begin{itemize}
\item translation: Removes all EquipmentItem in equippedItems.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mSDIM} InventoryManager}

\subsection*{Template Module}

Inventory

\subsection* {Uses}

\mref{mSDI}

\subsection* {Syntax}

\subsubsection* {Exported Types}

Item, List<>

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
OnItemChanged & ~ & ~  & ~\\
Add & Item & bool & ~\\
Remove & Item & ~  & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

items: $List<Item>$\\

\subsubsection* {State Invariant}

instance: $Inventory$
space: $\mathbb{N}$

\subsubsection* {Assumptions}

This module updates automatically as the user changes the player's inventory by interacting with GameObjects that are available to be stored in the inventory.

\subsubsection* {Access Routine Semantics}

\noindent OnItemChanged():
\begin{itemize}
\item description: Is called whenever a change occurs in the the state variable items. It is a delegate function that allows itself to perform different functionalities in different modules.
\item translation: *Updated in different modules; does nothing in this module*
\item output: None
\item exception: None
\end{itemize}

\noindent Add(Item item):
\begin{itemize}
\item translation: Adds item to the state variable list items if the number of Item in the list is less than state invariant space.
\item output: Returns true if an item is added to the list; returns false if an item is not added to the list
\item exception: None
\end{itemize}

\noindent Remove(Item item):
\begin{itemize}
\item translation: Removes item from the state variable list item.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mBHI} Interactable}

\subsection*{Template Module}

Interactable

\subsection* {Uses}

None

\subsection* {Syntax}

\subsubsection* {Exported Types}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Interact & ~ & ~  & ~\\
Update & ~ & ~ & ~\\
onFocused & Transform & ~  & ~\\
onDefocused & ~ & ~  & ~\\
onDrawGizmosSelected & ~ & ~  & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

isFocus: $bool$\\
player: $Transform$\\
hasInteracted: $bool$

\subsubsection* {State Invariant}

radius: $\mathbb{Q}$\\

\subsubsection* {Assumptions}

This module is attatched to any GameObject that the player can interact with. 

\subsubsection* {Access Routine Semantics}

\noindent Interact():
\begin{itemize}
\item description: It is a Virtual function that is re-programmable in all other modules that inherit \mref{mBHI}.
\item translation: *Updated in different modules; does nothing in this module*
\item output: None
\item exception: None
\end{itemize}

\noindent Update():
\begin{itemize}
\item translation: If isFocus = true, and hasInteracted = false, and if the distance between the player and the interactable GameObject is less than state invariant radius, perform Interact() and set hasInteracted = true.
\item output: None
\item exception: None
\end{itemize}

\noindent onFocused(Transform playerTransform):
\begin{itemize}
\item translation: sets isFocus = true, player = playerTransform, and hasInteracted = true.
\item output: None
\item exception: None
\end{itemize}

\noindent onDefocused():
\begin{itemize}
\item translation: sets isFocus = false, player = null, and hasInteracted = false.
\item output: None
\item exception: None
\end{itemize}

\noindent onDrawGizmosSelected():
\begin{itemize}
\item translation: Draws a yellow wire sphere around the interactable object of radius state invariant radius that is only visible in the scene view of Unity.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mBHIS} ItemStore}

\subsection*{Template Module}

ItemStore

\subsection* {Uses}

\mref{mSDI}, \mref{mBHI}, \mref{mSDIM}\\

\subsection* {Syntax}

\subsubsection* {Exported Types}

Item, Inventory

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Interact & ~ & ~  & ~\\
StoreItem & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

item: $Item$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

This module is attatched to any GameObject that the player can interact with. 

\subsubsection* {Access Routine Semantics}

\noindent Interact():
\begin{itemize}
\item description: It is an override function that is re-programs Interact() (from \mref{mBHI}) to perform StoreItem().
\item translation: *Updated in different modules; does nothing in this module*
\item output: None
\item exception: None
\end{itemize}

\noindent StoreItem():
\begin{itemize}
\item translation: Stores the state variable item into the inventory and destroys the GameObject.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mBHIC} InteractableController}

\subsection*{Template Module}

InteractableController

\subsection* {Uses}

\mref{mBHI}

\subsection* {Syntax}

\subsubsection* {Exported Types}

Interactable, RaycastHit, GameObject, Vector3, Physics, Input,

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Start & ~ & ~  & ~\\
Update & ~ & ~ & ~\\
pickup & ~ & ~ & ~\\
AttackEnemy & ~ & ~ & ~\\
SetFocus & Interactable & ~ & ~\\
RemoveFocus & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

focus: $Interactable$\\
hit: $RaycastHit$\\
player: $GameObject$\\
smooth: $\mathbb{Q}$

\subsubsection* {State Invariant}

distanceToSee = $\mathbb{Q}$

\subsubsection* {Assumptions}

This module is attatched to the GameObject with tag "MainCamera". 

\subsubsection* {Access Routine Semantics}

\noindent Start():
\begin{itemize}
\item translation: Initializes player with the GameObject with the tag "MainCamera"
\item output: None
\item exception: None
\end{itemize}

\noindent Update():
\begin{itemize}
\item translation: Performs pickup() and AttackEnemy()
\item output: None
\item exception: None
\end{itemize}

\noindent pickup():
\begin{itemize}
\item translation: If the the user performs an keyboard input of "E", and if the Raycast collides with an Interactable GameObject, perform SetFocus() with the interactable component attatched to the GameObject.
\item output: None
\item exception: None
\end{itemize}

\noindent AttackEnemy():
\begin{itemize}
\item translation: If the the user performs a left-mouse button input, and if the Raycast collides with an Interactable GameObject, perform SetFocus() with the interactable component attatched to the GameObject.
\item output: None
\item exception: None
\end{itemize}

\noindent SetFocus(Interactable newFocus):
\begin{itemize}
\item translation: If newFocus $\neq$ focus (state variable), calls the Interactable method onDefocused() on focus, and if focus $\neq$ null and set's focus = newFocus. Calls the Interactable method onFocused on the transform of the newFocus.
\item output: None
\item exception: None
\end{itemize}

\noindent RemoveFocus(Interactable newFocus):
\begin{itemize}
\item translation: If focus (state variable) $\neq$ null, calls the Interactable method onDefocused() on focus. Set's focus = null.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mBHEU} EquipmentUI}

\subsection*{Template Module}

EquipmentUI

\subsection* {Uses}

\mref{mSDEM}, \mref{mBHESU}

\subsection* {Syntax}

\subsubsection* {Exported Types}

Transform, Canvas, EquipmentManager, EquipmentSlot, 

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Start & ~ & ~  & ~\\
Update & ~ & ~ & ~\\
UpdateEquipmentUI & EquipmentItem, EquipmentItem & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

equipmentParent: $Transform$\\
equipmentUI: $Canvas$\\

\subsubsection* {State Invariant}

equipment: $EquipmentManager$\\
equipmentSlots: array of $EquipmentSlot$

\subsubsection* {Assumptions}

All the state variables are initialized by manually dragging GameObjects into the appropriate slot in Unity.

\subsubsection* {Access Routine Semantics}

\noindent Start():
\begin{itemize}
\item translation: Initializes State Invariant equipment as an instance of EquipmentManager, and equipmentSlots is initialized to store all the GameObjects with the component EquipmentSlot.\\
The EquipmentManager method onEquipmentChanged() is re-programmed to perform the method UpdateEquipmentUI().
\item output: None
\item exception: None
\end{itemize}

\noindent Update():
\begin{itemize}
\item translation: Upon keyboard input of "I", check if the equipmentUI is enabled (showing on screen). If it is enabled, de-enable it, else, enable it.
\item output: None
\item exception: None
\end{itemize}

\noindent UpdateEquipmentUI(EquipmentItem New, EquipmentItem Old):
\begin{itemize}
\item translation: If New = null, perform EquipmentSlot method clearSlot on equipmentSlots[(int)Old.equipSlot]. Else, perform EquipmentSlot method addItem() on equipmentSlots[(int)New.equipSlot] using New as the paramater for addItem().
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mBHESU} EquipmentSlotUI}

\subsection*{Template Module}

EquipmentSlot

\subsection* {Uses}

\mref{mSDEI}, \mref{mSDEM}

\subsection* {Syntax}

\subsubsection* {Exported Types}

Image, Button, EquipmentItem

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
addItem & EquipmentItem & ~  & ~\\
clearSlot & ~ & ~ & ~\\
onRemoveButton & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

icon: $Image$
removeButton: $Button$
item: $EquipmentItem$
slotNumber: $\mathbb{N}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

A module used as a component to GameObjects. State variable slotNumber will have it's value manually inputted.

\subsubsection* {Access Routine Semantics}

\noindent addItem(EquipmentItem newEquipment):
\begin{itemize}
\item translation: Set's state variable item = newEquipment, set's the sprite attribute of icon to the icon attribute of item (icon.sprite = item.icon), sets the enabled attribute of icon to true (icon.enabled = true), and sets the interactable attribute of removeButton to true (removeButton.interactable = true).
\item output: None
\item exception: None
\end{itemize}

\noindent clearSlot():
\begin{itemize}
\item translation: Set's state variable item = null, set's the sprite attribute of icon to null (icon.sprite = null), sets the enabled attribute of icon to false (icon.enabled = false), and sets the interactable attribute of removeButton to false (removeButton.interactable = false).
\item output: None
\item exception: None
\end{itemize}

\noindent onRemoveButton():
\begin{itemize}
\item translation: Calls the EquipmentManager method Unequip() using state variable slotNumber as the parameter.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mBHEI} InventoryUI}

\subsection*{Template Module}

EquipmentUI

\subsection* {Uses}

\mref{mSDIM}, \mref{mBHIS}

\subsection* {Syntax}

\subsubsection* {Exported Types}

Transform, Canvas, Inventory, InventorySlot, 

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Start & ~ & ~  & ~\\
Update & ~ & ~ & ~\\
UpdateInventoryUI & EquipmentItem, EquipmentItem & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

itemsParent: $Transform$\\
inventoryUI: $Canvas$\\

\subsubsection* {State Invariant}

inventory: $Inventory$\\
slots: array of $InventorySlot$

\subsubsection* {Assumptions}

All the state variables are initialized by manually dragging GameObjects into the appropriate slot in Unity.

\subsubsection* {Access Routine Semantics}

\noindent Start():
\begin{itemize}
\item translation: Initializes State Invariant inventory as an instance of Inventory, and slots is initialized to store all the GameObjects with the component InventorySlot.\\
The Inventory method onInventoryChanged() is re-programmed to perform the method UpdateInventoryUI().
\item output: None
\item exception: None
\end{itemize}

\noindent Update():
\begin{itemize}
\item translation: Upon keyboard input of "I", check if the inventoryUI is enabled (showing on screen). If it is enabled, de-enable it, else, enable it.
\item output: None
\item exception: None
\end{itemize}

\noindent UpdateEquipmentUI():
\begin{itemize}
\item translation: The InventorySlot method addItem() is called for every item in the Inventory state variable List items, and the InventorySlot method clearSlot() is called for every element in slots that does not have an item.
\item output: None
\item exception: None
\end{itemize}

\newpage

\section* {\mref{mBHISU} InventorySlotUI}

\subsection*{Template Module}

EquipmentSlot

\subsection* {Uses}

\mref{mSDIM}

\subsection* {Syntax}

\subsubsection* {Exported Types}

Image, Button, Item

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
addItem & Item & ~  & ~\\
clearSlot & ~ & ~ & ~\\
onRemoveButton & ~ & ~ & ~\\
useItem & ~ & ~ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

icon: $Image$
removeButton: $Button$
item: $Item$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

A module used as a component to GameObjects. State variable slotNumber will have it's value manually inputted.

\subsubsection* {Access Routine Semantics}

\noindent addItem(Item newItem):
\begin{itemize}
\item translation: Set's state variable item = newItem, set's the sprite attribute of icon to the icon attribute of item (icon.sprite = item.icon), sets the enabled attribute of icon to true (icon.enabled = true), and sets the interactable attribute of removeButton to true (removeButton.interactable = true).
\item output: None
\item exception: None
\end{itemize}

\noindent clearSlot():
\begin{itemize}
\item translation: Set's state variable item = null, set's the sprite attribute of icon to null (icon.sprite = null), sets the enabled attribute of icon to false (icon.enabled = false), and sets the interactable attribute of removeButton to false (removeButton.interactable = false).
\item output: None
\item exception: None
\end{itemize}

\noindent onRemoveButton():
\begin{itemize}
\item translation: Calls the Inventory method Remove() using state variable item as the parameter.
\item output: None
\item exception: None
\end{itemize}

\noindent useItem():
\begin{itemize}
\item translation: If item $\neq$ null, perform the Item method Use() on state variable item.
\item output: None
\item exception: None
\end{itemize}

\newpage
\section*{\mref{mBHG} Gun}

\subsection*{Template Module}

Gun

\subsection* {Uses}


\subsection* {Syntax}

\subsubsection* {Exported Types}

int, int, GameObject, AudioClip, AudioClip, float, float, Tranform, GameObject, Transform, float

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
	\hline
	\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
	\hline
	Start & ~ & ~  & ~\\
	Update & ~ & ~  & ~\\
	shoot & ~ & ~  & ~\\
	reload & ~ & ~ & ~\\
	createBullet & ~ & ~ & ~\\
	\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

ammoPerClip: $\mathbb{N}$\\
ammoInClip: $\mathbb{N}$\\
bullet: $GameObject$\\
gunShotSound: $AudioClip$\\
reloadSound: $AudioClip$\\
bulletSpeed: $\mathbb{R}$\\
fireRate: $\mathbb{R}$\\
barrelLocation: $Transform$\\
cam: $GameObject$\\
startPoint: $Transform$\\
startTime: $\mathbb{R}$\\
\subsubsection* {State Invariant}

ammoPerClip $>$ 0\\
startTime $\geq$ 0\\
ammoInClip $\leq$ ammoPerClip\\

\subsubsection* {Assumptions}

This module is attached to a GameObject which has a RangedWeapon component attached to it.

\subsubsection* {Access Routine Semantics}

\noindent Start():
\begin{itemize}
	\item translation: This method sets $startTime$ to the time of starting of the level and sets $cam$ to an object of type $GameObject$. This method then called the $reload()$ method, and the following actions then take place:\\
	barrelLocation $:=$ Transform of $Gun$\\
	startPoint $:=$ Transform of $cam$ 
	\item output: None
	\item exception: None
\end{itemize}

\noindent Update():
\begin{itemize}
	\item translation: This method sets the variable $elapsedTime$ to the currentTime.
	Then, this method checks if the user has pressed the left mouse button or the 'R' button. If the user has pressed the left mouse button and the value of $elapsedTime$ is more than $fireRate$, this method calls the $shoot$ method and resets $elapsedTime$ to 0.
	\item output: None
	\item exception: None
\end{itemize}

\noindent shoot():
\begin{itemize}
	\item translation: This method checks if the value of $ammoInClip$ is greater than 0. If yes, this method then calls the $createBullet$ method, plays a shooting animation and decreases the value of $ammoInClip$ by 1.\\ 
	If the value of $ammoInClip$ is 0, this method calls the $reload$ method.
	\item output: None
	\item exception: None
\end{itemize}

\noindent reload():
\begin{itemize}
	\item translation: This method sets the value of $ammoInClip$ to that of $ammoPerClip$ and plays the reload sound effect.
	\item output: None
	\item exception: None
\end{itemize}

\noindent createBullet():
\begin{itemize}
	\item translation: This method instantiates a $bullet$ GameObject and plays a gunshot sound effect.
	\item output: None
	\item exception: None
\end{itemize}

\newpage
\section*{\mref{mBHG} BulletDamage}

\subsection*{Template Module}

BulletDamage

\subsection* {Uses}

\mref{mSDZS}

\subsection* {Syntax}

\subsubsection* {Exported Types}

Trigger

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
	\hline
	\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
	\hline
	OnTriggerEnter & Collider & ~  & ~\\
	\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

damage: $\mathbb{R}$\\
enemyHit: $ZombieStats$

\subsubsection* {State Invariant}

damage $>$ 0
\subsubsection* {Assumptions}

The object collided with has a "collider" component attached to it.

\subsubsection* {Access Routine Semantics}

\noindent OnTriggerEnter(Collider other):
\begin{itemize}
	\item translation: This method detects if the bullet has collided with an object "other". If the object collided with has a tag "Enemy" then the health for that object is reduced by $damage$. This method then destroys the bullet object.
	\item output: None
	\item exception: None
\end{itemize}


\end {document}