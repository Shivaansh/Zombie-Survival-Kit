\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage[normalem]{ulem}
\usepackage{multirow}
\usepackage{float}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\DeclareRobustCommand{\hsout}[1]{\texorpdfstring{\sout{#1}}{#1}}

\newcounter{ftnum}
\newcommand{\fttheftnum}{F\theftnum}
\newcommand{\fref}[1]{T-F\ref{#1}}

\newcounter{nftnum}
\newcommand{\nftthenftnum}{NF\thenftnum}
\newcommand{\nfref}[1]{T-NF\ref{#1}}

\title{SE 3XA3: Test Plan\\Zombie Survival Kit}

\author{Team \#6, Group 6ix
		\\ Mohammad Hussain hussam17
		\\ Brian Jonatan jonatans
		\\ Shivaansh Prasann prasanns
}

\date{\today}

%\input{../Comments}

\begin{document}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
2018-10-26 & 1.0 & First Revision of Test Plan\\
2018-11-28 & 2.0 & Updated Final Revision of Test Plan\\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}



\section{General Information}

\subsection{Purpose}
This document is a description of the testing, validation and verification procedures that are to be implemented for Group 6's SFWR ENG 3XA3 project titled 'Zombie Survival Kit'. These test cases were conceived before the majority of the implementation and are therefore to be used by the project team for future references during implementation, testing and maintenance.
\subsection{Scope}
The project titled 'Zombie Survival Kit" is a game development kit to be used by aspiring game developers to use as a starting ground for their projects. As such, the scope of testing shall theoretically cover various game mechanics and functionalities, control schemes and performance.
\subsection{Acronyms, Abbreviations, and Symbols}

\begin{table}[!htbp]
\caption{\textbf{Table of Definitions}} \label{Table}

\begin{tabularx}{\textwidth}{p{3cm}X}
\toprule
\textbf{Term} & \textbf{Definition}\\
\midrule
Player & The in-game persona of the user\\
User & The person using Zombie Survival Kit\\
Pickable Object & An in-game object that the player can pick, drop, use and store in the Inventory\\
Inventory & An in-game storage option used to store various objects\\
\bottomrule
\end{tabularx}

\end{table}	

\subsection{Overview of Document}

This document comprises of details regarding the test initiatives, test procedures, tools and techniques to be used, a testing schedule and facts which together serve as a reference for the test team to successfully test the software being developed.
\section{Plan}
	
\subsection{Software Description}
Zombie Survival Kit is a starting ground for aspiring game developers to help them create their own Zombie Survival First Person Shooter game, and has been built using the Unity 3D engine and C\#. Testing would involve verifying that the various mechanics and functionalities in place are working correctly and reliably.
 
\subsection{Test Team}
The test team comprises of the three members of Group 6, as well as all volunteers who help test the product via feedback provided in a Google Form after trying a demo of the product.

\subsection{Automated Testing Approach}
The Unity3D engine shall play an instrumental role in the automated testing process. Many features of the product need no user input and are implemented automatically, which verifies their correctness. \hsout{The interaction of certain game features with others (like collisions) are proved via mutual implication.} {\color{magenta} For unit testing, the Unity Test framework built into the Unity 3D engine will be used. Test Cases will be generated and implemented to test the various methods implemented in certain modules which require user input either directly or indirectly, and implement a mechanic which requires various GameObjects, for eg: the shooting of a bullet.
Certain modules cannot be tested using Unity Test as they have one or more GameObject(s) which are not supported by Unity Test. For these modules, manual testing will be conducted.}

\subsection{Testing Tools}
\hsout{Since the game is being developed using the Unity 3D game engine, which incorporates a compiler and a debugger, we will be using the outputs seen in the engine to guide our testing processes.}{\color{magenta} The main tools being used for testing are the Unity Test framework (incorporated within the Unity 3D engine) as well as Google Forms which will be used to receive feedback from the volunteer testers.}

\subsection{Testing Schedule}
		
See Gantt Chart at the following url : \url{https://gitlab.cas.mcmaster.ca/jonatans/Zombie_Survival_Kit/blob/018d6c62a03216446c1a934df1e510ec412cc91e/Doc/DevelopmentPlan/Gantt%20Chart%20-%20Group%206.gan} 

\section{System Test Description}
	
\subsection{Tests for Functional Requirements}

\subsubsection{{\color{magenta} F1.} The player must be able to move forward, left, down, and right using the WASD keys {\color{magenta} on the keyboard.}}
		
\paragraph{Player Movement} 

\begin{enumerate} 

\item{Player-Movement-M-1\\} \refstepcounter{ftnum} \label{F1-1}

Type: Manual \\
					
Initial State: A scene is initially paused. The scene will have the player initialized at \hsout{the center of} {\color{magenta} a certain position on }the playable map, and \hsout{a tree} {\color{magenta} some trees } \hsout{will be initialized at a position beside} {\color{magenta} are present around} the player to act as a stationary marker.\\
					
Input: Start scene button, WASD keys \\
					
Output: Changes on screen. \\
					
How test will be performed:\\ The user will start the scene and the user will press down on the WASD keys. If the user notices that the position of the player changes in the scene relative to the \hsout{tree} {\color{magenta}trees}, the test is concluded and is considered to have passed. If the player position stays the same relative to the tree's position while the user is pressing down on the WASD keys, the test is considered to have failed. \\

\end{enumerate}

\subsubsection{{\color{magenta} F2.} The player must be able to look in all directions by moving their mouse.} 
		
\paragraph{Camera Movement}

\begin{enumerate}

\item{Camera-Movement-M-1\\} \refstepcounter{ftnum} \label{F2-1}

Type: Manual\\
					
Initial State: A scene is initially paused. The scene will have the player initialized at \hsout{the center of} {\color{magenta} a certain position on }the playable map, and \hsout{a tree} {\color{magenta} some trees } \hsout{will be initialized at a position beside} {\color{magenta} are present around} the player to act as a stationary marker.\\
					
Input: Start scene button, mouse movement \\
					
Output: Changes on screen. \\
					
How test will be performed:\\ The user will start the scene and the user will move the mouse in any direction. If the user notices that the perspective of the player changes in the scene using the \hsout{tree} {\color{magenta}trees} as a marker, the test is concluded and is considered to have passed. If the \hsout{tree} {\color{magenta}trees} stays at the same position on screen while the mouse is moving, the test is considered to have failed. \\

\end{enumerate}

\subsubsection{{\color{magenta} F3.} Zombie enemies must walk back and forth between random points in their ‘spawn circle’, which imitates them walking around.} 
		
\paragraph{'Spawn' Circle}

\begin{enumerate}

\item{Spawn-Circle-A-1\\}  \refstepcounter{ftnum} \label{F3-1}

Type: \hsout{Automated}{\color{magenta}Manual}\\
					
Initial State: A zombie enemy object is initialized at the center of its 'spawn' circle that will have a predetermined position on the playable map.\\
					
Input: void \\
					
Output: void or assertion error.\\
					
How test will be performed:\\ \hsout{A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given for the zombie to move in any direction on the x, y plane of the the playable map, and will continue to move in that same direction until the zombie's position hits any point on the 'spawn' circle's perimeter; to which the zombie will change its directional movement and the process starts over again. Assert statements will be used to check if the zombie's position never passes any point along the 'spawn' circle's perimeter. After each change in direction occurs, a counter will be recorded. Once the counter reaches a specified amount, the test is concluded and the test is considered to have passed and nothing is returned (void). Any assertion errors will be considered as a failed test.}
{\color{magenta}The user can see the zombie intialized at a certain position on the screen. If the zombie seems to be moving around a certain location on the ground, the test is said to have passed. If such a behaviour is not shown by the zombie, the test is considered to be a failure. The results are recorded with the help of a Google Form.} \\

\end{enumerate}

\subsubsection{{\color{magenta} F4.} Zombie enemies must start attacking the player when they come within a certain radius.}
		
\paragraph{Attack Radius}

\begin{enumerate}

\item{Attack-Radius-A-1\\} \refstepcounter{ftnum} \label{F4-1}

Type: \hsout{Automated}{\color{magenta}Manual}\\
					
Initial State: A zombie enemy object is initialized at the center of its 'spawn' circle that will be have a predetermined position on the playable map. The player \hsout{object} is initialized outside the zombie's attack radius.\\
					
Input: \hsout{void} {\color{magenta} Keyboard input (WASD keys and Shift button)} \\
					
Output: void or assertion error \\
					
How test will be performed:\\  \hsout{A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given to the player to move towards the zombie's attack radius.  Once the player is within the zombie enemy's attack radius, the zombie will be given commands to attack the player, and the zombie's attack animation will be enabled. Assertion statements will be used to check if the zombie's attack animation is enabled. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.}
{\color{magenta} The user takes control of the player and moves towards the zombie instantiated on the screen using the WASD keys on the keyboard. Once the player is within a certain distance of the zombie, the zomvie should start attacking the player, and the zombie character model will trigger the attack animation. If such a behavior is observed then the test is said to have passed, otherwise the test is deemed a failure. The results are recorded with the help of a Google Form.}\\

\end{enumerate}

\subsubsection{{\color{magenta} F5.} Zombie enemies must follow the player if \hsout{they start running away while the zombie is attacking them} {\color{magenta} the player is at a certain distance from the zombie.}} 

\paragraph{Zombie Follows Player}

\begin{enumerate}

\item{Zombie-Follows-Player-A-1\\} \refstepcounter{ftnum} \label{F5-1}

Type: \hsout{Automated}{\color{magenta}Manual}\\
					
Initial State: A zombie enemy object is initialized at the center of its 'spawn' circle that will be have a predetermined position on the playable map. The player \hsout{object} is initialized at a distance outside of the zombie's 'spawn' circle.\\
					
Input: \hsout{void} {\color{magenta} Keyboard input (WASD keys and Shift button)} \\
					
Output: void or assertion error \\
					
How test will be performed:\\\hsout{ A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given for the zombie to move in any direction on the x, y plane of the the playable map and will have its position constrained by it's spawn circle. Commands will be given to the player to move towards the zombie's 'spawn' circle center. If the position of the player and the zombie is at a certain distance from each other, commands will be given to the zombie to move its position towards the player and for the player to move away from the zombie's position. The change in position of the player and the zombie will be the same. Assertion statements will be used to check if the distance between the zombie's position and the player's position remains the same, and if the position of the zombie and player are not the same; while the zombie's position is not greater than a specified distance from the center of the 'spawn' circle. Once the zombie's position reaches this distance, the test is concluded. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.} 
{\color{magenta} The user assumes control of the player object and moves towards the zombie using the WASD keys on the keyboard. Once the player is within a certain distance of the zombie(the attack radius of the zombie), the zombie should start attacking the player. When this happens, the user should try to move the player away from the zombie. If the zombie tries to follow the player while the player is moving away from the zombie, the test is considered successful. If this behavior is not observed, the test is said to have failed. The results are recorded with the help of a Google Form.}\\

\end{enumerate}

\subsubsection{{\color{magenta} F6.} If the player runs past a certain radius from the zombie’s original spawn location, the zombie must return to their circle.} 

\paragraph{Zombie Returns to 'Spawn' Circle Center}

\begin{enumerate}

\item{Zombie-Return-Spawn-Circle-A-1\\} \refstepcounter{ftnum} \label{F6-1}

Type: \hsout{Automated}{\color{magenta}Manual}\\
					
Initial State: A zombie enemy object is initialized at the center of its 'spawn' circle that will be a predetermined position on the playable map. The player \hsout{object} is initialized at a distance outside of the zombie's 'spawn' circle.\\
					
Input: \hsout{void} {\color{magenta} Keyboard input (WASD keys and Shift button)} \\
					
Output: void or assertion error \\
					
How test will be performed:\\ \hsout{A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given for the zombie to move in any direction on the x, y plane of the the playable map and will have its position constrained by it's spawn circle. Commands will be given to the player to move towards the zombie's 'spawn' circle center. If the position of the player and the zombie is at a certain distance from each other, commands will be given to the zombie to move its position towards the player and for the player to move away from the zombie's position. The change in position of the player and the zombie will be the same. Assertion statements will be used to check if the distance between the zombie's position and the player's position remains the same, and if the position of the zombie and player are not the same; while the zombie's position is not greater than a specified distance from the center of the 'spawn' circle. Once the zombie's position reaches this distance, the zombie will return to the center of its 'spawn' circle, concluding the test. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.}
{\color{magenta}  The user assumes control of the player and moves towards the zombie instantiated on the screen using the WASD keys on the keyboard. Once the player is within a certain distance of the zombie (the attack radius of the zombie), the zombie should start attacking the player. Once this is observed, the user tries to run away from the zombie by holding down the Shift key on the keyboard while using the WASD keys to move away from the zombie. After reaching a certain distance away from the zombie, the zombie should give up following the player and move back to its original spawn location. If this behaviour is observed, the test is considered a success, otherwise it is considered a failure. The results are recorded with the help of a Google Form.}\\

\end{enumerate}

\subsubsection{{\color{magenta} F7.} Different types of zombies must have different statistics (health, damage, {\color{magenta} and attack speed). Different types of zombies will be distinguishable by their different appearances.}} 

\paragraph{Zombie Stats}

\begin{enumerate}

\item{Zombie-Stats-A-1\\} \refstepcounter{ftnum} \label{F7-1}

Type: \hsout{Automated}{\color{magenta}Manual}\\
					
Initial State: \hsout{All different zombie enemy type objects are initialized.} {\color{magenta} The game scene consists of the player object and diferent zombie objects.}
					
Input: \hsout{void } {\color{magenta} Keyboard and Mouse}\\
					
Output: void \hsout{or assertion error} \\
					
How test will be performed:\\ \hsout{A test script will be created that initializes the test with the specified initial state. Within the test script, instructions will be given to compare all the different stats fields of each zombie enemy type. An assertion statement will be used to check if all values within a stat field are different for each zombie enemy type. Once all assertion tests are passed, the test is conlcuded. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.}
{\color{magenta} The game scene consists of the player and some enemy objects instantiated on a terrain. The user takes control of the player and uses the keyboard to move towards a zombie enemy and uses the left mouse button to attack the zombie. The user attacks and kills multiple zombies in this manner. If different zombies take a different number of hits to kill, the test is said to have passed, otherwise the test is considered a failure.}\\

\end{enumerate}

\subsubsection{{\color{magenta} F8.} Zombies must have randomly generated chance of dropping items the player can \hsout{use} {\color{magenta} equip} or consume when killed.} 

\paragraph{Appearing Drops}

\begin{enumerate}

\item{\sout{Appearing-Drops-A-1} {\color{magenta} Appearing-Drops-DM-1}\\} \refstepcounter{ftnum} \label{F8-1}

Type: \sout{Automated} {\color{magenta} Dynamic, Manual}\\
					
Initial State: Two zombie enemy objects are initialized at the center of its 'spawn' circle that will be have a predetermined position on the playable map. The player object is initialized at a distance of the zombie's attack radius.\\
					
Input: \sout{void} {\color{magenta} Start scene button, WASD keys, E key, I key, left mouse button, mouse movement}\\
					
Output: \sout{void or assertion error} {\color{magenta} }\\
					
How test will be performed:\\ \sout{A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given to the player to attack one of the zombies. An assertion statement will be used to check if that zombie's current health value is lower than than its initial health value. Once the zombie's health value reaches zero, an item object will appear at a chance of 100\% at the position of the zombie before the zombie object is set to null (representing the first zombie's death). An assertion statement will be used to check if there exists an item object at the position where the zombie had died. The second zombie will undergo the same process as the first zombie, but an item object appearing at this zombie's position will have a chance of 0\%. An assertion statement will be used to check if there does not exists an item object at the position of the zombie before the zombie object is set to null (representing the second zombie's death), and the test is concluded. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.}\\
{\color{magenta} The user will start the scene and the user will press down on the WASD keys to move the player towards one of the zombies. Once the player is within attacking distance, the user will attack the zombie by pressing the left mouse button until the zombie dies. The user will check if a drop has appeared and then pick up the drop using the E key. The user will press the I key to check if the item has been stored in the invenotry. The user will repeat this process for the second zombie. If any of the checks fail, the test has failed. Otherwise, the test has passed.}\\

\end{enumerate}

\subsubsection{\hsout{Func. Req. 9: Dropped items must be automatically deleted if not picked up within a certain time}}

\paragraph{\hsout{Disappearing Drops}}

\begin{enumerate}

\item{\hsout{Disappearing-Drops-A-1}\\} 

\sout{Type: Automated}\\
					
\sout{Initial State: A zombie enemy objects is initialized at the center of its 'spawn' circle that will be have a predetermined position on the playable map. The player object is initialized at a distance of the zombie's attack radius.}\\
					
\sout{Input: void }\\
					
\sout{Output: void or assertion error} \\
					
\sout{How test will be performed:}\\ \sout{A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given to the player to attack one of the zombies. An assertion statement will be used to check if that zombie's current health value is lower than than its initial health value. Once the zombie's health value reaches zero, an item object will appear at a chance of 100\% at the position of the zombie before the zombie object is set to null (representing the zombie's death). An assertion statement will be used to check if there exists an item object at the position where the zombie had died. Instructions to wait for the amount of time it takes for the item to disappear are given. An assertion statement will be used to check if there does not exists an item object at the same position, and the test is concluded. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.}\\

\end{enumerate}

\subsubsection{{\color{magenta} F9.} The player must be able to pick up items they are looking at with the ‘interact’ key.} 

\paragraph{Pickup Drops}

\begin{enumerate}

\item{\sout{Pickup-Drops-A-1} {\color{magenta} Pickup-Drops-DM-1} \\} \refstepcounter{ftnum} \label{F9-1}

Type: \sout{Automated} {\color{magenta} Dynamic, Manual}\\
					
Initial State: A player object is initialized at any predetermined position, and an item object is also initialized near the player's position.\\
					
Input: \sout{void} {\color{magenta} Start scene button, WASD keys, E key, mouse movements}   \\
					
Output: \sout{void or assertion error} {\color{magenta} The item object will disappear once the item has been picked up by the player} \\
					
How test will be performed:\\ \sout{A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given to the player to move towards the item and, once close enough, to change the camera's foward position to the item. Then, the 'interact' key will be inputted. An assertion statement will be used to check if there exists the item in the player's inventory, and the test is concluded. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.}\\
{\color{magenta} The user will start the scene and the user will press down on the WASD keys to move towards the item. The user will move the mouse until the reticle is on the item, and then they will press the E key to pick up the item. If the item disappears from the scene, then the test was successful. If it stays in the scene, the test has failed}\\

\end{enumerate}

\subsubsection{{\color{magenta} F10.} The player must be able to access their inventory by pressing the ‘inventory’ key{\color{magenta} , and will have a maximum space of 20 items.}} 

\paragraph{Inventory Access}

\begin{enumerate}

\item{\sout{Inventory-Access-A-1} {\color{magenta} Inventory-Access-DM-1}\\} \refstepcounter{ftnum} \label{F10-1}

Type: \sout{Automated} {\color{magenta} Dynamic, Manual}\\
					
Initial State: A player object is initialized at any predetermined position\\
					
Input: \sout{void} {\color{magenta} Start scene button, I key}\\
					
Output: \sout{void or assertion error} {\color{magenta} The Inventory UI will appear on screen}\\
					
How test will be performed:\\ \sout{The user will start the scene and the user will press down on the WASD keys. If the user notices that the position of the player changes in the scene relative to the tree, the test is concluded and is considered to have passed. If the player position stays the same relative to the tree's position while the user is pressing down on th WASD keys, the test is considered to have failed.} \\
{\color{magenta} The user will start the scene. Once the scene has started, the user will press down on the I key. If the user observes that the Inventory UI appears on the screen, the test has succeeded; if not, the test has failed}\\

\end{enumerate}

\subsubsection{{\color{magenta} F11.} The player must be able to equip, consume, \hsout{delete, and move around} {\color{magenta} and drop} items in their Inventory {\color{magenta} UI} using the \hsout{mouse} {\color{magenta} LMB.}} 

\paragraph{\hsout{Use Items Move Items} {\color{magenta} Use Remove Items}}

\begin{enumerate}

\item{\sout{Use-Move-Items-M-1} {\color{magenta} Use-Remove-Items-DM-1} \\} \refstepcounter{ftnum} \label{F11-1}

Type: {\color{magenta} Dynamic, }Manual \\
					
Initial State: A scene is initially paused. A player object is initialized at the center of the playable map. Equipment and consumable item objects are initialized close to the player's position.\\
					
Input: Start scene button, WASD keys, mouse movement, mouse left-click, \sout{'inventory' key, 'interact' key, 'de-equip' button} {\color{magenta} I key, E key, U key, remove button}\\
					
Output: Items picked up by the player will appear in the Inventory UI. Equipment items used will be equipped and shown in the Equipment UI. Consumable items used will dissappear from the Inventory UI and the player's health will increase. Items removed from the Inventory UI will be removed and appear as an item game object in front of the player and drop to the terrain.\\
					
How test will be performed:\\ The user will start the scene and the user will press down on the WASD keys to move the player towards the items and stop once the player is close enough to the item to interact with it. The user will then use the mouse to change the camera view until rectile is over the item and then the user will press the E key to pick it up. The user will do this for all items. The user will then press the \sout{'inventory'} {\color{magenta} I} key to open the inventory UI, and use the mouse to hover over either item icon. The user will press down on the left mouse button to use the item. If the item used is the consumable, the user will check the player's health value to see if it has increased by a specified amount. The user will also check if the item no longer exists in the player's inventory. The user will then press down on the left mouse button to use {\color{magenta} one of} the equipment item. The user will check if the equipment has been equipped in one of the player's equipment slot and if the equipment item has disappeared from the player's inventory. \sout{The user will then press the 'de-equip' button and will check if the equipment is no longer in the player's equipment slot, but back in the player's inventory. The user will move the equipment item to another slot by pressing and holding down the left mouse button on the item icon, and drag the mouse to an empty slot in the player's inventory. The user will check if the item has moved to its intended spot.} The user will then press the left mouse button on the remove button \sout{in the top right corner of the slot the item is in} {\color{magenta} for all items in the inventory}. The user will check if the \sout{item has} {\color{magenta} items have} been removed from the player's inventory and \sout{has} {\color{magenta} have} appeared at some close distance in front of the player. If any of the user's check fails, the test is considered to have failed. Otherwise, the test was passed.\\

\item{{\color{magenta} Use-Remove-Items-BUA-2}\\} \refstepcounter{ftnum} \label{F11-2}

{\color{magenta} Type: Black Box, Unit, Automatic}\\
					
{\color{magenta} Initial State: void}\\
					
{\color{magenta} Input: void}\\
					
{\color{magenta} Output: void}\\
					
{\color{magenta} How test will be performed:}\\{\color{magenta} The methods that implement adding items to the inventory, using items, and removing items from the inventory will be tested. Assertion statements will be used for expected outputs. If an assertion errors does not occur, then the test was successful. If an assertion error does occur, then the test has failed.} \\
\end{enumerate}

\subsubsection{{\color{magenta} F12. The player must be able to unequip items in their Equipment UI using the LMB or the `unequip all’  key.}} 

\paragraph{{\color{magenta} Unequip}}

\begin{enumerate}

\item{{\color{magenta} Unequip-DM-1}} \refstepcounter{ftnum} \label{F12-1}

{\color{magenta} Type: Dynamic, Manual} \\
					
{\color{magenta} Initial State: A player object and equipment item objects are initialized at a predetermined position}\\
					
{\color{magenta} Input: Start scene button, WASD keys, E key, I key mouse movement, left mouse button}\\
					
{\color{magenta} Output: The equipment items, when used, will appear in the Equipment UI. Items removed from the Equipment UI will reappear in the Invenotry UI}\\
					
{\color{magenta}How test will be performed:}\\ {\color{magenta} The user will start the scene and the user will press down on the WASD keys to move the player towards the items and stop once the player is close enough to the item to interact with it. The user will then use the mouse to change the camera view until rectile is over the item and then the user will press the E key to pick it up. The user will do this for all items. The user will then press the I key to open the inventory UI, and use the mouse to hover over the equipment item icon. The user will press down on the left mouse button to equip the item. The user will do this for all equipment items in the inventory, and check if each item has been transferred over to the Equipment UI. The user will then use the  the remove button on one of the items in the Equipment UI, and then press the U key. The user will check if all items have been removed from the Equipment UI and has reappeared in the Inventory UI. If any of the user's check fails, the test is considered to have failed. Otherwise, the test was passed.}

\item{{\color{magenta} Unequip-BUA-2}\\} \refstepcounter{ftnum} \label{F12-2}

{\color{magenta} Type: Black Box, Unit, Automatic}\\
					
{\color{magenta} Initial State: void}\\
					
{\color{magenta} Input: void}\\
					
{\color{magenta} Output: void}\\
					
{\color{magenta} How test will be performed:}\\{\color{magenta} The methods that implement equipping and unequipping items will be tested. Assertion statements will be used for expected outputs. If an assertion errors does not occur, then the test was successful. If an assertion error does occur, then the test has failed.} \\

\end{enumerate}

\subsubsection{{\color{magenta} F13.} The player must be able to fire/use \hsout{their equipped weapon} {\color{magenta} an equipped gun or axe} by pressing the left mouse button (LMB).} 

\paragraph{Attack Items}

\begin{enumerate}

\item{Attack-Items-M-1\\} \refstepcounter{ftnum} \label{F13-1}

Type: Manual \\
					
Initial State: A scene is initially paused. A player object is initialized at the center of the playable map. A weapon type equipment is initialized to the player's corresponding equipment slot. A zombie enemy object is initialized close to the enemy
					
Input: Start scene button, WASD keys, mouse movement, left mouse button\\
					
Output: Changes on screen.\\
					
How test will be performed:\\ The user will start the scene and the user will press down on the WASD keys to move the player towards the zombie until the player is within attacking range from the zombie. The user will move the mouse until the zombie is in the middle of the user's screen and will then press the left mouse button. The user will observe if the zombie's health is decreasing after each attack. If any of the user's check fails, the test is considered to have failed. Otherwise, the test was passed.

\end{enumerate}

\subsubsection{{\color{magenta} F14.} If the player has a firearm equipped, \hsout{they must be able to aim down sights using the right mouse button (RMB)} {\color{magenta} the user can reload the gun using the ‘reload’ key. The mazimum amount of bullets will be 7.}} 

\paragraph{Aiming}

\begin{enumerate}

\item{Aiming-M-1\\} \refstepcounter{ftnum} \label{F14-1}

Type: Changes on screen \\
					
Initial State: A scene is initially paused. A player object is initialized at the center of the playable map. A weapon type equipment is initialized to the player's corresponding equipment slot.
					
Input: Start scene button, mouse movement, right left-click\\
					
Output: void\\
					
How test will be performed:\\ The user will start the scene and the user will press down and hold on the right mouse button. The user will check if the firearm object moves to a position that shows the player is "aiming down their sights". The player will then move the mouse while still holding down the right mouse button and will check if where the firearm is pointing at changes. If any of the user's check fails, the test is considered to have failed. Otherwise, the test was passed. \\

\end{enumerate}

\subsubsection{{\color{magenta} F15.} The environment must slowly go through a day and night cycle.} 

\paragraph{Day and Night}

\begin{enumerate}

\item{Day-Night-A-1\\} \refstepcounter{ftnum} \label{F15-1}

Type: Automated \\
					
Initial State: Day time at the current system time.
					
Input: void\\
					
Output: void or assertion error\\
					
How test will be performed:\\ A test script will be created that initializes the test with the specified initial state. Within the test script, instructions will be given for the function that changes day time into night time to run, and to check how much time has passed from when the test script started. Once the time needed for day time to become night time has passed, an assertion statement will check if it is night time. Once again, instructions will be given to check how much time has passed after the previously mentioned assertion statement has been checked. Once the time needed for night time to become day time, an assertion statement will check if it is day time. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.\\

\end{enumerate}

\subsubsection{{\color{magenta} F16.} The player must lose health when hit by a zombie.} 

\paragraph{Zombie Attack}

\begin{enumerate}

\item{Zombie-Attack-A-1\\} \refstepcounter{ftnum} \label{F16-1}

Type: \hsout{Automated} {\color{magenta} Manual} \\
					
Initial State: A zombie enemy object is initialized at the center of its 'spawn' circle that will be have a predetermined position on the playable map. The player object is initialized outside the zombie's attack radius.\\
					
Input: \hsout{void} {\color{magenta} Keyboard} \\
					
Output: void or assertion error \\
					
How test will be performed:\\  \hsout{A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given to the player to move towards the zombie's attack radius.  Once the player is within the zombie enemy's attack radius, the zombie will be given commands to attack the player and the zombie's attack animation will be enabled. An assertion statements will be used to check after each zombie attack if the player's health is lower than its previous health. Once the player's health reaches zero, the test is concluded. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.}
{\color{magenta} The user assumes control of the player and guides the player to a zombie using the WASD keys on the keyboard. Once inside the zombie's attack radius, the zombie should start attacking the player. The player's health bar at the bottom left corner of the screen should become shorter in lenght, indicating a loss of health. If this behaviour is observed, the test is said to have passed, otherwise it is considered a failure. The results are recorded with the help of a Google Form.}\\

\end{enumerate}

\subsubsection{{\color{magenta} F17.} Zombies must lose health when hit by the player {\color{magenta} by using the LMB once the player is within attacking distance from the zombie.}} 

\paragraph{Player Attack}

\begin{enumerate}

\item{Player-Attack-A-1\\} \refstepcounter{ftnum} \label{F17-1}

Type: \hsout{Automated} {\color{magenta} Manual} \\
					
Initial State: A zombie enemy object is initialized at the center of its 'spawn' circle that will be have a predetermined position on the playable map. The player object is initialized outside the zombie's attack radius.\\
					
Input: \hsout{void} {\color{magenta} Keyboard and Mouse} \\
					
Output: void or assertion error \\
					
How test will be performed:\\  \hsout{A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given to the player to move and change its camera forward positon towards the zombie. Once the player is within attacking distance, the player will be given commands to attack the zombie and the player's attack animation will be enabled. An assertion statement will be used to check, after each player attack, if the zombie's health is lower than its previous health. Once the zombie's health reaches zero, the test is concluded. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.} {\color{magenta}The user assumes control of the player by using the WASD keys to move the player and the mouse to move the camera and attack. The player walks up to a zombie and keeps attacking the zombie till the zombie dies. If the zombie dies, this test is considered a success, a failure otherwise.}\\

\end{enumerate}

\subsubsection{{\color{magenta} F18.} Players or zombies must die when they reach 0 health.} 

\paragraph{Death}

\begin{enumerate}

\item{Death-A-1\\} \refstepcounter{ftnum} \label{F18-1}

Input: \hsout{void} {\color{magenta} Keyboard and Mouse} \\
					
Initial State: Two zombie enemy objects is initialized at the center of its 'spawn' circle that will be have a predetermined position on the playable map. The player object is initialized outside the zombie's attack radius.\\
					
Type: \hsout{Automated} {\color{magenta} Manual} \\
					
Output: void or assertion error \\
					
How test will be performed:\\  \hsout{A test script will be created that initializes the test with the specified initial state. Within the test script, commands will be given to the player to move and change its camera forward positon towards the first zombie. Once the player is within attacking distance, the player will be given commands to attack the first zombie and the player's attack animation will be enabled. Assertion statements will be used to check, after each player attack, if the first zombie's health is lower than its previous health. Once the first zombie's health reaches zero, the first zombie will have died. An assertion statement will be used to check that the first zombie not longer exists (null). Commands will then be given to the second zombie to move towards the player. Once the player is within the zombie's attack radius, the zombie's attack animation will begin.  An assertion statements will be used to check after each zombie attack if the player's health is lower than its previous health. Once the player's health reaches zero, the player is dead. An assertion statement will be used to check if the player is dead and the test is concluded. No assertion errors indicate a passed test, whereas assertion errors indicate a failed test.}
{\color{magenta}The user assumes control of the player object and guides the player towards a zombie. When the player enters the zombie's attack radius, the zombie starts attacking the player. The user attacks the zombie using the left mouse button. After multiple attacks, the zombie dies and drops a pickup on the ground. The user then guides the player to another zombie, and once in the zombie's attack radius, the zombie starts attacking the player. This time, the player does not attack the zombie or run away. The health bar at the bottom left corner should continues to deplete and once it reaches zero, the screen displays the "Game Over" message. Only if all these conditions are observed is the test considered a pass.}\\

\end{enumerate}

\subsubsection{\hsout{Func. Req. 19: Upon player death, the game must reset}} 

\paragraph{\hsout{Reset}}

\begin{enumerate}

\item{\sout{Reset-M-1}\\}

\sout{Type: Manual} \\
					
\sout{Initial State: A player object is initialized in the center of the playable map and a zombie enemy object is initialized at a distance from the player that is within the zombie's attack radius.}\\
					
\sout{Input: Scene start button} \\
					
\sout{Output: Changes on screen} \\
					
\sout{How test will be performed:}\\  \sout{The user will start the scene. The user will check if the zombie is attacking the player and if the player's health is decreasing after each zombie attack. Once the player's health decreases to zero, the user will check if the scene resets to its inital state where the process begins all over again. If any of the user's check fails, the test is considered to have failed. Otherwise, the test was passed.} \\

\end{enumerate}

\subsubsection{{\color{magenta} F19. An Inventory UI will give the user a visual representation of the player's inventory and will be accessable by pressing the ‘inventory’ key.}} 

\paragraph{{\color{magenta} InventoryUI}}

\begin{enumerate}

\item{{\color{magenta} InventoryUI-DM-1}\\} \refstepcounter{ftnum} \label{F19-1}

{\color{magenta} Type: Dynamic, Manual}  \\
					
{\color{magenta} Initial State: A player object will be instantiate at a predetermined location}\\
					
{\color{magenta} Input: Start scene button,  I key}\\
					
{\color{magenta} Output: The Inventory UI will appear on the bottom right corner of the screen after the user presses down on the I key, and the Inventory UI will disappear when the I key is pressed once again.}\\
					
{\color{magenta} How test will be performed:}\\  {\color{magenta} The user will start the scene and the user will press down on the I key. The user will check if the Inventory UI appears. on the bottom right corner of the screen. Then the user will press the I key again and check if the Inventory UI has disappeared from the screen. If any of the user's check fails, the test is considered to have failed. Otherwise, the test was passed.}\\

\end{enumerate}

\subsubsection{{\color{magenta} F20. An Equipment UI will give the user a visual representation of the player's equipped items and will be appear with the Inventory UI by pressing the ‘inventory’ key.}} 

\paragraph{{\color{magenta} Equipment UI}}

\begin{enumerate}

\item{{\color{magenta} EquipmentUI-DM-1}\\} \refstepcounter{ftnum} \label{F20-1}

{\color{magenta} Type: Dynamic, Manual }  \\
					
{\color{magenta} Initial State: A player object will be instantiate at a predetermined location}\\
					
{\color{magenta} Input: Start scene button,  I key}\\
					
{\color{magenta} Output: The Equipment UI will appear on the top left corner of the screen after the user presses down on the I key, and the Equipment UI will dissappear when the I key is pressed once again. }\\
					
{\color{magenta} How test will be performed:}\\  {\color{magenta} The user will start the scene and the user will press down on the I key. The user will check if the Equipment UI appears. on the top left corner of the screen. Then the user will press the I key again and check if the Equipment UI has disappeared from the screen. If any of the user's check fails, the test is considered to have failed. Otherwise, the test was passed.}\\

\end{enumerate}

\subsubsection{{\color{magenta} F21. A Player UI will give the user a visual representation of the player's health and remaining bullets if a gun is equipped to the player. The Player UI will also consist of a reticle.}} 

\paragraph{{\color{magenta} Player UI}}

\begin{enumerate}

\item{{\color{magenta} PlayerUI-SM-1}\\}  \refstepcounter{ftnum} \label{F21-1}

{\color{magenta} Type: Static, Manual}  \\
					
{\color{magenta} Initial State: A player object will be instantiate at a predetermined location}\\
					
{\color{magenta} Input: Start scene button}\\
					
{\color{magenta} Output: A Player UI on the bottom left corner of the screen}\\
					
{\color{magenta} How test will be performed:}\\  {\color{magenta} The user will start the scene and the user will check if there exists a Player UI on the bottom left corner of the screen. If any of the user's check fails, the test is considered to have failed. Otherwise, the test was passed.}\\

\end{enumerate}

\subsection{Tests for Nonfunctional Requirements}

\subsubsection{Look and Feel Requirements}

\paragraph{Look and Feel}

\begin{enumerate}
	
	\item{Graphics-F-1\\} \refstepcounter{nftnum} \label{NF1}
	
	Type: Functional \\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit.\\
	
	Input/Condition: Follow the instructions of the surveyor. \\
	
	Output/Result: Filled Survey. \\
	
	How test will be performed: A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do. \\
	The surveyor will ask the user to start the game and to look at all the initialized objects and playable map.\\
	Afterwards, they will fill in an answer to a question relating to how the graphics appear to them.
	
	\item{Ease-of-Use-F-1\\} \refstepcounter{nftnum} \label{NF2}
	
	Type: Functional \nfref{NF2}\\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit. \\
	
	Input: Follow the instructions of the surveyor. \\
	
	Output: Filled Survey. \\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do.\\  
	The surveyor will tell the user all the possible features of the game. Then the surveyor will ask the user to use the keyboard or mouse to perform the features. \\
	Afterwards, they will fill in an answer to a question relating to how intuitive or easy it is to use all the possible input commands through the mouse and keyboard.\\
	
	\item{Ease-of-Use-F-1\\} \refstepcounter{nftnum} \label{NF3}
	
	Type: Functional \\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit. \\
	
	Input: Follow the instructions of the surveyor. \\
	
	Output: Filled Survey. \\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do. 
	The surveyor will ask the user to input all the possible input commands.
	Afterwards, they will fill in an answer to a question relating to how responsive the game feels when inputting all the commands through the mouse and/or keyboard.\\
	
\end{enumerate}

\subsubsection{Usability and Humanity Requirements}

\begin{enumerate}
	
	\item{Min-Learn-F-1\\} \refstepcounter{nftnum} \label{NF4}
	
	Type: Functional \\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit. \\
	
	Input/Condition: Follow the instructions of the surveyor. \\
	
	Output/Result: Filled Survey. \\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do. \\
	The surveyor will teach the user all the possible input commands. \\
	Afterwards, they will fill in an answer to a question relating to how easy it was to learn all the input commands through the mouse and/or keyboard.\\				
	
\end{enumerate}

\subsubsection{Performance Requirements}

\begin{enumerate}
	
	\item{Start-Time-F-1\\} \refstepcounter{nftnum} \label{NF5}
	
	Type: Functional \\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit. \\
	
	Input/Condition: Follow the instructions of the surveyor.
	
	Output/Result: Filled Survey.
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do. \\ 
	The surveyor will ask the user to time how long it takes to start the game. Then the surveyor will ask the user to start the game. \\
	Afterwards, they will fill in an answer to a question relating to how fast did it take for the scene to load. \\
	
	\item{FPS-F-1\\} \refstepcounter{nftnum} \label{NF6}
	
	Type: Functional \\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit. The script developed by Dave Hampson to display the framerate of the scene in Unity will be added and initalized to the scene. \\
	
	Input/Condition: Start scene button \\
	
	Output/Result: Frames per second \\
	
	How test will be performed:\\ The user will start the scene and will read the framerate on the screen produced by the script by Dave Hampson (http://wiki.unity3d.com/index.php/FramesPerSecond). \\ 
	If the framerate runs at a speed equal to or higher than 60 frames per second while performing all the features of Zombie Survival Kit, the test passes. Otherwise the test failed.\\
	
	\item{Close-Time-F-1\\} \refstepcounter{nftnum} \label{NF7}
	
	Type: Functional \\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit. \\
	
	Input/Condition: Follow the instructions of the surveyor. \\
	
	Output/Result: Filled Survey. \\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do. \\
	The surveyor will ask the user to start the scene, and once the scene starts, the surveyor will ask the user to time how long it takes to close the game. The surveyor will then ask the user to close the game. \\
	Afterwards, they will fill in an answer to a question relating to how fast did it take for the scene to stop playing. \\
	
	\item{\sout{Close-Time-F-1} {\color{magenta} Enough-Ram-F-1}\\} \refstepcounter{nftnum} \label{NF8}
	
	Type: Functional \\
	
	Initial State: void \\
	
	Input/Condition: Checking to see that the \sout{space} {\color{magenta} ram} needed to \sout{download the playable executable of} {\color{magenta} play} Zombie Survival Kit does not surpass 1GB. \\
	
	Output/Result: The space needed to download the playable executable of Zombie Survival Kit \\
	
	How test will be performed:\\ The user will check how much \sout{space} {\color{magenta} ram} \sout{is required to download the playable executable of} Zombie Survival Kit {\color{magenta} takes up}. If \sout{space} {\color{magenta} the amount ram used} \sout{required} does not exceed 1GB, the test has passed. Otherwise, the test has failed. \\
	
\end{enumerate}

\subsubsection{Safety Critical Requirements}

\begin{enumerate}
	
	\item{Enough-Space-F-1\\} \refstepcounter{nftnum} \label{NF9}
	
	Type: Functional\\
	
	Initial State: The playable exectuable of Zombie Survival Kit is not downloaded.\\
	
	Input/Condition: The playable exectuable of Zombie Survival Kit will not be downloaded if there is not enough space in the hard-drive. \\
	
	Output/Result: Downloaded the playable exectuable of Zombie Survival Kit, or the playable exectuable of Zombie Survival Kit was not downloaded\\
	
	How test will be performed:\\ A computer without the space required to download the playable exectuable of Zombie Survival Kit will try to download it. If the download is interuppted due to lack of hard-drive space, the test has passsed. Otherwise the test has failed. \\
	
\end{enumerate}

\subsubsection{Precision Requirements}

\begin{enumerate}
	
	\item{Player-Attack-Animation-to-Effect-F-1\\} \refstepcounter{nftnum} \label{NF10}
	
	Type: Functional\\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit.\\
	
	Input/Condition: Follow the instructions of the surveyor.\\
	
	Output/Result: Filled Survey.\\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do. \\
	The surveyor will ask the user to move the player towards a zombie, and to have the player attack the zombie.\\
	Afterwards, they will fill in an answer to a question relating to how precise the zombie's attack animation was to the effect it had on the player's health.\\		
	
	\item{Time-Day-Night-Transition-F-1\\} \refstepcounter{nftnum} \label{NF11}
	
	Type: Functional\\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit.\\
	
	Input/Condition: Follow the instructions of the surveyor.\\
	
	Output/Result: Filled Survey.\\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do. \\
	The surveyor will tell the user before starting the scene, how long it will take for the environment to change from day to night and night to day. Then the surveyor will ask the user to time how long it takes for day to become night and night to become day, after starting the scene. \\
	Afterwards, they will fill in an answer to a question relating to how precise the change in day or night in the game was to the amount of time that has passed.\\
	
	\item{Zombie-Attack-Animation-to-Effect-F-1\\} \refstepcounter{nftnum} \label{NF12}
	
	Type: Functional\\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit.\\
	
	Input/Condition: Follow the instructions of the surveyor.\\
	
	Output/Result: Filled Survey.\\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do.\\ 
	The surveyor will ask the user to move the player towards a zombie, and let the zombie attack the player.\\
	Afterwards, they will fill in an answer to a question relating to how precise the zombie's attack animation was to the effect it had on the player's health.\\	
	
	\item{Distance-to-Pickup-Item-F-1\\} \refstepcounter{nftnum} \label{NF13}
	
	Type: Functional \\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit. \\
	
	Input/Condition: Follow the instructions of the surveyor. \\
	
	Output/Result: Filled Survey. \\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do. \\
	The surveyor will ask the user to move the player towards the the item, and to stop at any distance from the item before pressing the 'interact' key to pick up the item.
	Afterwards, they will fill in an answer to a question relating to how intuitive it was to bring the player to a certain distance from the item before they pressed the 'interact' key to pick up the item.\\
	
\end{enumerate}

\subsubsection{Reliability and Availability Requirements}

\begin{enumerate}
	
	\item{Reliable-Input-Commands-F-1\\} \refstepcounter{nftnum} \label{NF14}
	
	Type: Functional \\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit.\\
	
	Input/Condition: Follow the instructions of the surveyor.\\
	
	Output/Result: Filled Survey.\\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should make the player (in the game) do. \\
	The surveyor will ask the user to perform all the possible input commands and will tell the user what will happen in the game before the commands are inputted. \\
	Afterwards, they will fill in an answer to a question relating to how reliabile the intended output would appear, after inputting each input command from the mouse and keyboard.\\
	
	\item{Play-When-On-F-1\\} \refstepcounter{nftnum} \label{NF15}
	 
	Type: Functional\\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit.\\
	
	Input/Condition: Follow the instructions of the surveyor.\\
	
	Output/Result: Filled Survey.\\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should do. \\
	The surveyor will instruct the user to execute the executable for Zombie Survival Kit, start the scene, and then close the game ten times.\\
	Afterwards, they will fill in an answer to a question relating to how often the game executed from the ten times the user opened and closed the game. \\
	
\end{enumerate}

\subsubsection{Cultural Requirements}

\begin{enumerate}
	
	\item{Culture-Discretion-F-1\\} \refstepcounter{nftnum} \label{NF16}
	
	Type: Functional\\
	
	Initial State: Scene is paused. All game mechanics, game functions/features, game objects, and interactions will be intialized for the user to begin playing the current game Zombie Survival Kit.\\
	
	Input/Condition: Follow the instructions of the surveyor.\\
	
	Output/Result: Filled Survey.\\
	
	How test will be performed:\\ A person (not in group 6) will be selected to try the game Zombie Survival Kit. The user will follow the surveyor's instructions as to what they should do. \\
	The surveyor will instruct the user to perform all the features implemented in Zombie Survival Kit\\
	Afterwards, they will fill in an answer to a question relating to if they found any animations, game objects, or sounds offensive to any culture or political background the user is able to think of.\\
	
\end{enumerate}

\subsubsection{Non-function Requirements not being tested on}

\begin{enumerate}

	\item{{\color{magenta} Operational and Environmental Requirements}\\}
	
	{\color{magenta} The operational and Environmental requirements are expected system requirements that the user will have to run the game, and includes requirements detailing what partner applications are used to develop Zombie Survival Kit. These are design decisions that Group 6ix feels to bring out the best experience of Zombie Survival Kit which do not require testing.}
	
	\item{Security Requirements\\}
	\sout{1. Zombie Survival Kit shall not require any personal information from the user.}\\ 

	We cannot test what we do not require the game to do. Therefore there are no tests for the Security Requirements.

	\item{Legal Requirements\\}

	We cannot test the license in which Zombie Survival is under.
	
	\item{Health and Safety Requirements\\}
	\sout{1. Users with a history of epilepsy or sensitivity to flashing lights should notuse this product.}\\
	
	\sout{2. The product should be used in a well lit environment}\\
	
	\sout{3. Correct posture should be ensured by the user while sitting on computer}\\
	
	\sout{4. After every hour of use, a 10 minute break is highly recommended.}\\
	
	\sout{5. If the user experiences watering of eyes, a sensation of dizziness or nausea,}\\
	
	\sout{use of the product should be ceased immediately.}\\
	
	\sout{6. The product should never be used if the user is feeling sleepy.}\\
	
	\sout{7. The computer being used should be well ventilated and should be cooled adequately.}\\
	
	\sout{8. The frame rate should be at least 60 FPS at all times to prevent motion sickness, and frame time variance should be checked and maintained at a maximum of 16 ms.}\\
	
	\sout{9. The age of the user should be at least 12 years.} \\
	
	These requirements concerning the safety of the user and the equipment required for Zombie Survival Kit will not be tested on because failure to any of these requirements may consitute a health hazard.\\
	
	
\end{enumerate}

\subsection{Traceability Between Test Cases and Requirements}
\sout{All the functional and non-function test cases as stated above have detailed instructions as to what constitutes a passed or failed test case. Each step within each test case are also described allowing for high traceability between test cases and requirements.}\\

\begin{table}[H]
\centering
\begin{tabular}{p{0.5\textwidth} p{0.4\textwidth}}
\toprule
\textbf{Functional Requirements} & \textbf{Tests}\\
\midrule
F1 & \fref{F1-1}\\
F2 & \fref{F2-1}\\
F3 & \fref{F3-1}\\
F4 & \fref{F4-1}\\
F5 & \fref{F5-1}\\
F6 & \fref{F6-1}\\
F7 & \fref{F7-1}\\
F8 & \fref{F8-1}\\
F9 & \fref{F9-1}\\
F10 & \fref{F10-1}\\
F11 & \fref{F11-1}, \fref{F11-2}\\
F12 & \fref{F12-1}, \fref{F12-2}\\
F13 & \fref{F13-1}\\
F14 & \fref{F14-1} \\
F15 & \fref{F15-1} \\
F16 & \fref{F16-1} \\
F17 & \fref{F17-1} \\
F18 & \fref{F18-1} \\
F19 & \fref{F19-1} \\
F20 & \fref{F20-1} \\
F21 & \fref{F21-1} \\
\bottomrule
\end{tabular}
\caption{Trace Between Functional Requirements and Tests}
\label{TblRT}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{p{0.5\textwidth} p{0.4\textwidth}}
\toprule
\textbf{Non-Functional Requirements} & \textbf{Tests}\\
\midrule
NF1 & \nfref{NF1}\\
NF2 & \nfref{NF2}\\
NF3 & \nfref{NF3}\\
NF4 & not tested\\
NF5 & \nfref{NF4}\\
NF6 & not tested\\
NF7 & \nfref{NF5}\\
NF8 & \nfref{NF6}\\
NF9 & \nfref{NF7}\\
NF10 & \nfref{NF8}\\
NF11 & \nfref{NF9}\\
NF12 & \nfref{NF10}, \nfref{NF12}\\
NF13 & \nfref{NF11}\\
NF14 & \nfref{NF13}\\
NF15 & \nfref{NF14}\\
NF16 & \nfref{NF15}\\
NF17 &  not tested\\
NF18 &  not tested\\
NF19 &  not tested\\
NF20 &  not tested\\
NF21 &  not tested\\
NF22 &  not tested\\
NF23 &  not tested\\
NF24 &  not tested\\
NF25 &  not tested\\
NF26 &  \nfref{NF16}\\
NF27 &  not tested\\
NF28 &  not tested\\
NF29 &  not tested\\
NF30 &  not tested\\
NF31 &  not tested\\
NF32 &  not tested\\
NF33 &  not tested\\
NF34 &  not tested\\
NF35 &  not tested\\
NF36 &  not tested\\
\bottomrule
\end{tabular}
\caption{Trace Between Non-Functional Requirements and Tests}
\label{TblRT}
\end{table}


\section{Tests for Proof of Concept}

\subsection{Movement and Camera}
		
\begin{enumerate}

\item{Movement\\}

Type: Manual
					
Initial State: The player is instantiated at the center of the terrain and can see a tree on the screen.
					
Input: W-A-S-D, Shift and Space keys on the keyboard.
					
Output: Change of player perspective in the game scene.
					
How test will be performed:
The user will press the W key on the keyboard. This causes the player to move towards the tree seen on the screen, and cross a red marking on the ground. This confirms that the player is moving forward with respect to the starting position. If the player's position remains the same as the starting position after pressing the W key, the test is considered a failure. The A, S and D keys move the player left, backwards and right respectively in a similar manner.
\newline
By pressing and holding the Shift key on the keyboard, the player should move at a faster speed compared to when the Shift key is not held down. If this behavior is not observed, the test is a failure.\newline
Pressing the Space bar shall cause the player to jump in the current position. If the player is in motion when the Space bar is pressed, the player should move in the direction of movement even when off the ground. If this behavior is not observed, the test is a failure.
					
\item{Camera\\}

Type: Manual
					
Initial State: The player is instantiated at the center of the terrain and can see a tree on the screen.
					
Input: Mouse movement
					
Output: Change of player perspective in the game scene.
					
How test will be performed: 
The user stays in the initial starting point, and moves the mouse in an arbitrary direction. The in-game camera should move in the same direction as the mouse, causing a change in the perspective of the player with respect to the game world. If this behavior is observed, the test is successful.
\newline
The speed of movement would depend on the hardware settings and are subject to change on each computer. If the player perspective fails to change after moving the mouse, the test is declared a failure. 

\end{enumerate}

\subsection{Inventory System}

\begin{enumerate}
	
\item{Inventory UI\\}

Type: Manual

Initial State: The player is instantiated at the center of the terrain and can see a tree on the screen.

Input: I button on keyboard

Output: A UI element shows up on the screen.

How test will be performed:
At any point of time, the user shall press the I key on the keyboard. This shall halt mouse-based camera movement, and a grid of items shall appear on the right hand side of the game screen. In case this behavior is not observed, the test is considered to have failed.

\item{Item pickup\\}

Type: Manual

Initial State: The player is instantiated at the center of the terrain and can see a tree on the screen.

Input: W-A-S-D, E and I buttons on keyboard, mouse movement.

Output: A new item shall be visible in the Inventory UI.

How test will be performed:
The user moves towards a pickable object using the W-A-S-D keys, and then uses the mouse to look at it. When the user is looking at the pickable object, the user presses the E button on the keyboard. This should make the pickable object disappear from the game screen. At this point, by pressing the I button on the keyboard, the user can see the pickable object appear as a small icon in the Inventory UI. This would indicate success of this test.

\item{Item drop\\}

Type: Manual

Initial State: The player is instantiated at the center of the terrain and can see a tree on the screen.

Input: I button on keyboard, mouse movement.

Output: An item shall be removed from the Inventory UI.

How test will be performed:
The user opens the Inventory UI using the I button. If the Inventory UI shows no objects in it, it means that the Inventory is empty and nothing can be dropped from it. If there is an object in the Inventory UI, the object icon has a small 'x' button on the top right corner of the icon. By left-clicking on this 'x' icon, the user can drop this item from the Inventory. If after clicking the 'x' button, the item still remains in the inventory, this test has failed.

\item{Item consumption\\}

Type: Manual

Initial State: The player is instantiated at the center of the terrain and can see a tree on the screen.

Input: I button on keyboard, mouse movement.

Output: Player stats shall change.

How test will be performed:
The user opens the Inventory UI using the I button. If the Inventory UI shows no objects in it, it means that the Inventory is empty and nothing can be consumed from it. If there is an object in the Inventory UI, the user can left-click on the object icon to use the item. As an example, if the player has a fruit object in the inventory, then by clicking on the icon for the fruit object in the inventory UI, the player's health level is increased. 

\end{enumerate}

\subsection{Enemy pathfinding}

\begin{enumerate}
	\item {Enemy moving to player\\}

	Type: Automated
	
	Initial State: The player is instantiated at the center of the terrain and can see a tree on the screen, enemy zombies are seen moving around at various places in the game scene.
	
	Input: W-A-S-D and Shift keys on keyboard.
	
	Output: Player stats shall change.
	
	How test will be performed:
	The user sees many enemies walking around a position in the game scene. When the user moves the player (using the WASD and Shift keys) to within a certain distance of an enemy zombie, the zombie starts moving towards the player. If the player now moves away from the zombie, then at reaching a certain distance from the zombie, the zombie stops chasing the player and then starts moving about a position.
	
\end{enumerate}
	
\section{Comparison to Existing Implementation}	

\hsout{Group 6's version of this implementation has almost caught up to and replicated the existing open source implementation's functionalities. Currently, both implementations have a basic testing environment, and not a full playable terrain created using Unity. Both programs also have an inventory and equipment system implemented, allowing the user to pick up various items into their inventory and consume/equip them as they please.}
{\color{magenta} Group 6 has finished the implementation of all the functionalities present in the existing open source implementation. Group 6's implementation now has a sample terrain with various models like trees, bridges and mountains, as well as fully functional melee and range weapons, a working inventory system, a day and night cycle, as well as sound effects to indicate that an attack has been completed. The sounds effects are an extra feature not present in the exisiting implementation.}\\

The open source project has implemented visibly equipping melee and ranged weapons and using them with animations, \hsout{whereas Group 6 has not yet developed that far into the aesthetics of the project and currently only has a basic left-click enemy damage system}, {\color{magenta}which differs from Group 6's implementation in that Group 6's implementation uses still images for weapons.} \hsout{Although behind on that aspect, a} {\color{magenta}A } basic enemy AI system has been developed where the enemies wander around in a certain radius, and follow/attack the player when they get too close.  The existing implementation does not have enemy AI and only has a still object that you can practice attacking with your weapons. \\

\hsout{Parallel testing will not be used since much of the existing implementation is not fully complete or put together. Although it would have been useful, there are not many components to test that would be benefiecial in testing the current implementation aswell. The current project was inspired by the existing implementation in an attempt to finish and make it what it was designed to be like, but since the start of development it has become very independent and not attached to the open source code, making running tests on it not an effective use of time}
{\color{magenta} Testing for the implementation has been conducted using a mix of Automated and Manual testing. Unity Test scripts have been used for various functional and non-functional requirements. Due to some restrictions imposed by the nature of some GameObjects (such as in the modules 'Enemy', 'Zombie' and 'ZombieStats' ), some components have been tested manually with the help of volunteers, who provide feedback through a Google Form.}.


\section{Unit Testing Plan}

\subsection{Unit testing of internal functions}

Unit tests for internal functions will be accomplished using ASSERT statements. \hsout{As of now, these statements will be embedded in the C\# scripts in each testable function. In order to test that the code is functional, each statement will be placed under the main part of each function} {\color{magenta} These ASSERT statements are located in dedicated test scripts which use the Unity Test framework. Each test script corresponds to one module in the implementation.}. Inside, certain values will be asserted to check if they are equal, or certain statements will be inputted and checked if they evaluate to true or false which will prove the correctness of the code.   \\

For example, assertion statements will be used to make sure the combat system is correct. After the code for the enemy attacking the player runs, there will be an assertion to check if the player's new health is equal to the player's old health minus the enemy's attack value. If the assertion passes, it is known that the the enemy has successfully attacked and reduced the player's health. The same thing is tested for the opposite scenario, where the player attacks the enemy. There is an assertion to check if the enemy's new health is equal to the enemy's old health minus the player's attack value. \\

Another example of unit testing that will be done is for the inventory system. Once the player picks up an item, it should be added into the first available inventory slot. Assertion statements can be used to check if the item was successfully placed into the slot. This is done by running an assertion that checks if the first available inventory slot is filled with an Item of the type that was just picked up. If the assertion passes, the player has successfully picked up the item into their inventory\\

{\color{magenta} All test scripts for unit testing of internal functions are found in: \\
\href{https://gitlab.cas.mcmaster.ca/jonatans/Zombie\_Survival\_Kit/tree/Brian\_Final/src/Zombie\%20Survival\%20Kit/Assets/Scripts/Test\%20Scripts}{Test-Scripts} \\}


Below is the outline of how the Unit Test scripts verify correctness: \newline

\subsubsection{Test\textunderscore CharacterCombat}

\paragraph{Purpose} Verify that the Attack() method functions properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item GameManager (GameObject): Required for Unity Test
	\item  character (GameObject): The character that carries out an attack
	\item  character2 (GameObject):
	The character that is attacked
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item attacker (CharacterCombat): Reference to the CharacterCombat script attached to 'character'.
	\item attackerStats (CharacterStats): Reference to the CharacterStats script attached to 'character'.
	\item defenderStats (CharacterStats): Reference to the CharacterStats script attached to 'character2'.
\end{itemize}
\paragraph{Description: }
	This script asserts that the health of 'character2' after the Attack method is called by 'character' is less than its original value.
\paragraph{Teardown: } All the variables created in the Setup section are removed.
%%%%%%%%%%%%%
\subsubsection{Test\textunderscore CharacterStats}

\paragraph{Purpose} Verify that the TakeDamage() method functions properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item GameManager (GameObject): Required for Unity Test
	\item  player (GameObject): A reference to the player object
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item stats (CharacterStats): The CharacterStats script attached to the player.

\end{itemize}
\paragraph{Description: }
This script asserts that the health level (which is initially 100) is equal to 49 after the $TakeDamage$ method is called and a damage of 51 is caused.
\paragraph{Teardown: } All the variables created in the Setup section are removed.
%%%%%%%%%%%%%%%%%%%
\subsubsection{Test\textunderscore ConsumableItem}

\paragraph{Purpose} Verify that the Use() method functions properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item GameManager (GameObject): Required for Unity Test
	\item  player (GameObject): A reference to the player object
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item item1 (ConsumableItem): A reference to an instance of a ConsumableItem script.
	
\end{itemize}
\paragraph{Description: }
This script asserts when item1 is equipped, the inventory is not empty, and after the Use() method is called on item1, item1 is 'consumed' and the inventory is now empty.
\paragraph{Teardown: } All the variables created in the Setup section are removed.
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Test\textunderscore DayLightController}


\paragraph{Purpose} Verify that the 'Directional Light' GameObject rotates periodically.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
%	\item GameManager (GameObject): Required for Unity Test
%	\item  player (GameObject): A reference to the player object
%	\item  GunUI (GameObject): The Gun ammo count UI
%	\item AxeUI (GameObject): The Axe UI element of the canvas
%	\item item1 (ConsumableItem): A reference to an instance of a ConsumableItem script.
	\item daylightobject (GameObject): A reference to the Directional Light object.
	
\end{itemize}
\paragraph{Description: }
This script asserts that the rotation of the Directional Light object at a certain time differs from the rotation of the Directional Light object after 2 seconds.

\paragraph{Teardown: } All the variables created in the Setup section are removed.

%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Test\textunderscore EquipmentItem}

\paragraph{Purpose} Verify that the Use() method functions properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item GameManager (GameObject): Required for Unity Test
	\item  player (GameObject): A reference to the player object
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item item1 (EquipmentItem): A reference to an instance of a EquipmentItem script.
	
\end{itemize}
\paragraph{Description: }
This script asserts when item1 is not equipped, the inventory is not empty, the equipment UI is empty, and that after the Use() method is called on item1, item1 is 'equipped' and the inventory is now empty, whereas the equipment UI is no longer empty.
 
\paragraph{Teardown: } All the variables created in the Setup section are removed.

%%%%%%%%%%

\subsubsection{Test\textunderscore EquipmentManager}

\paragraph{Purpose} Verify that the Equip() method functions properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item GameManager (GameObject): Required for Unity Test
	\item  player (GameObject): A reference to the player object
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item InventoryUI (GameObject): The Inventory UI element of the canvas
	\item item1 (EquipmentItem): A reference to an instance of a EquipmentItem script.
	\item item1 (EquipmentItem): An item with the name "ChestArmor", that has the EquipmentItem script attached as a component.
	\item item2 (EquipmentItem): An item with the name "Cloak", that has the EquipmentItem script attached as a component.
	\item item3 (EquipmentItem): An item with the name "RangeWeapon", that has the EquipmentItem script attached as a component.
	
\end{itemize}
\paragraph{Description: }
This script asserts when the Equip() method is called on item1, item2 and item3, they are all assigned to a different slot in the equipment UI.

\paragraph{Teardown: } All the variables created in the Setup section are removed.
%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Test\textunderscore Gun}

\paragraph{Purpose} Verify that the shoot() and reload() methods functions properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item bullet (GameObject): An instance of a 'bullet' gameObject
	\item cam (GameObject): A reference to the camera in the game.
	\item GameManager (GameObject): Required for Unity Test
	\item  PlayerUI (GameObject): A reference to the player UI element of the canvas
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item rangeWeapon (EquipmentItem): A reference to an instance of a EquipmentItem object with the Gun script attached to it.
	
\end{itemize}
\paragraph{Description: }
This script asserts when the shoot() method is called on the gun,  a bullet gameObject is instantiated and that the value of the ammo in the gun is reduced by 1. This script also asserts that when the reload() method is called, the value of the ammo in the gun is reset back to the max value of 7.

\paragraph{Teardown: } All the variables created in the Setup section are removed.

%%%%%%%%%%%%%%%%
\subsubsection{Test\textunderscore Inventory}

\paragraph{Purpose} Verify that the Add(), InventoryEquipmentConsumable() and RemoveFromInventory() methods functions properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item GameManager (GameObject): Required for Unity Test
	\item  player (GameObject): A reference to the player UI element of the canvas
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item item1 (EquipmentItem): A reference to an instance of a EquipmentItem object with the Gun script attached to it.
	
\end{itemize}
\paragraph{Description: }
To test the Add() method, this script asserts that when item1 is added to the inventory using the Add() methods, the inventory contains item1 and is not empty.
\newline
To test the InventoryEquipmentConsumable() method, this script asserts that before calling the InventoryEquipmentConsumable() method, the inventory contains item1, but not after calling the method.
\newline
To test the RemoveFromInventory() method, this script asserts that when this method is called, item1 exists but is independent from the inventory (the inventory does not contain item1).

\paragraph{Teardown: } All the variables created in the Setup section are removed.
%%%%%%%%%%%%%%%%%%%

\subsubsection{Test\textunderscore ItemStore}

\paragraph{Purpose} Verify that the Interact() method functions properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item GameManager (GameObject): Required for Unity Test
	\item  player (GameObject): A reference to the player UI element of the canvas
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item GameItem (GameObject): An instance of a "HeadArmor" prefab.
	\item item (EquipmentItem): A reference to a "HeadArmor" object which shall be residing in the inventory.
	
\end{itemize}
\paragraph{Description: }
This method asserts that when the Interact() method is called, the inventory contains item and GameItem does not exist anymore.

\paragraph{Teardown: } All the variables created in the Setup section are removed.

%%%%%%%%%%%%%%%%%%%
\subsubsection{Test\textunderscore PlayerStats}

\paragraph{Purpose} Verify that the OnEquipmentChanged() and Eat() methods function properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item GameManager (GameObject): Required for Unity Test
	\item  player (GameObject): A reference to the player UI element of the canvas
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item stats (PlayerStats): A reference to the PlayerStats script attached to 'player'.
	\item item1 (ConsumableItem): A ConsumableItem instance.
	\item item2 (ConsumableItem): A ConsumableItem instance.
	
\end{itemize}
\paragraph{Description: }
To test the Eat() method, this script asserts that the value of 'curHealth' for 'stats' before and after calling the Eat() method is different, and that the value of 'curHealth' after the Eat() method has been called is greater than what it was before by a difference of the value of the 'healthModifier' variable for 'item1'. In this test, 'item1' has the name 'Apple'.
\newline
To test the OnEquipmentChanged() method, this script asserts that when 'item1' is equipped, the values of armor and damage stats for the player are increased by the values of the defence and attack modifiers associated with 'item1' respectively. Also, when item1 is swapped with item2 (by calling the OnEquipmentChanged() method),  the values of armor and damage stats for the player are updated by the values of the defence and attack modifiers associated with 'item2' respectively.
For this test, 'item1' and 'item2' are named 'Axe' and 'RangeWeapon' respectively.
\paragraph{Teardown: } All the variables created in the Setup section are removed.
%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Test\textunderscore Stat}

\paragraph{Purpose} Verify that the AddToStat(), GetValue() and RemoveFromStat() methods function properly.

\paragraph{Setup: } The following variables are needed for this test:
\begin{itemize}
	\item GameManager (GameObject): Required for Unity Test
	\item  player (GameObject): A reference to the player UI element of the canvas
	\item  GunUI (GameObject): The Gun ammo count UI
	\item AxeUI (GameObject): The Axe UI element of the canvas
	\item damage (Stat): A reference to the Stat script attached to 'player'.

	
\end{itemize}
\paragraph{Description: }
To test the AddToStat() method, this script asserts that when a value is added to 'stat' by calling the AddToStat(), stat then contains that value.
\newline
To test the GetValue() method, this script asserts that when two values are passed to 'stat' using the AddToStat() method, GetValue() then returns the sum of those two values.
\newline
To test the RemoveFromStat() method, this script asserts that when 4 values are added to 'stat' using the AddToStat() method, and then one value (say 'x') is removed from 'stat' using the RemoveFromStat() method, 'stat' does not contain 'x'.
\paragraph{Teardown: } All the variables created in the Setup section are removed.
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%% output unit testing
\subsection{\hsout{Unit testing of output files}}		
%%%%%%%%% output unit testing

\sout{Currently, the implementation does not generate any output files, so no tests are necessary. As a design choice, it was decided to reset the game when the player dies to give the development kit more of a survival theme. Also since this is just a dev kit and not a fully fledged video game, saving the game and generating output files is not necessary. If any output files are added, this section will be updated and test cases will be added.}



%\bibliographystyle{plainnat}
%
%\bibliography{SRS}
%
%\newpage
%
\newpage
\section{Appendix}

This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Usability Survey Questions?}

In order to complete manual integration testing, Google Surveys will be given out to a set number of people with instructions to play our game, and provide relevant feedback in the form. Sample questions include: \\

1. On a scale of 1-5, rate the functionality and fluidness of the enemy AI system. Provide any relevant comments, bug reports, or other feedback below.\\

2. On a scale of 1-5, rate the functionality and fluidness of the combat system. Provide any relevant comments, bug reports, or other feedback below.\\

3. On a scale of 1-5, rate the functionality and fluidness of the inventory/equipment system. Provide any relevant comments, bug reports, or other feedback below.\\

4. On a scale of 1-5, rate the functionality and fluidness of the movement system. Provide any relevant comments, bug reports, or other feedback below.\\

5. On a scale of 1-5, rate the functionality and fluidness of the environment and picking up items. Provide any relevant comments, bug reports, or other feedback below.\\

\end{document}